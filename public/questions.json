{
  "algorytmy": [
    {
      "question": "Rekurencja jest w niektórych sytuacjach naturalnym sposobem budowy algorytmu.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Rekurencja to technika programowania, w której funkcja wywołuje samą siebie. Jest szczególnie użyteczna do rozwiązywania problemów o strukturze fraktalnej, co czyni ją naturalnym i eleganckim podejściem w takich przypadkach."
    },
    {
      "question": "Sortowanie przez wybieranie jest bardzo szybkim algorytmem.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Sortowanie przez wybieranie nie jest szybkim algorytmem. Należy do prostych metod sortowania o złożoności czasowej O(n²), co czyni go nieefektywnym dla dużych zbiorów danych. Algorytm ten w każdej iteracji znajduje najmniejszy element w nieposortowanej części i zamienia go z pierwszym elementem tej części."
    },
    {
      "question": "Największe standardowe liczby całkowite w C++ mają 18 cyfr.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Największe standardowe liczby całkowite w C++ (typ `unsigned long long`) mogą przechowywać wartości do około 1.8 x 10¹⁹, co daje 19-20 cyfr. Standard nie narzuca dokładnej liczby cyfr, ale gwarantuje minimalny zakres, który jest zazwyczaj większy niż 18 cyfr."
    },
    {
      "question": "Jeśli program implementujący dany algorytm nie zatrzymuje się, to prawdopodobnie jest to błąd programisty.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Gdy program wpada w nieskończoną pętlę lub ulega zawieszeniu, najczęściej wskazuje to na błąd w jego logice. Obowiązkiem programisty jest zapewnienie, że algorytm zakończy swoje działanie dla każdego dopuszczalnego zestawu danych wejściowych."
    },
    {
      "question": "Wydajność algorytmów sortowania porównuje się za pomocą testów wykorzystujących generatory liczb pseudolosowych.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tak, testy wydajnościowe często używają danych generowanych pseudolosowo, aby symulować typowe przypadki użycia. Oprócz tego, używa się też danych o specyficznych właściwościach (np. już posortowanych, posortowanych odwrotnie), aby sprawdzić, jak algorytm radzi sobie w przypadkach skrajnych."
    },
    {
      "question": "Dla danych losowych algorytm QuickSort (sortowanie szybkie) zwykle okazuje się najszybszy.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "QuickSort, ze względu na swoją średnią złożoność czasową O(n log n) i niskie stałe czynniki, jest w praktyce jednym z najszybszych algorytmów sortowania opartych na porównaniach dla dużych, nieuporządkowanych zbiorów danych."
    },
    {
      "question": "Jeśli w trakcie działania programu liczba typu `int` przekroczy swój zakres, zostanie wyświetlony komunikat o błędzie.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "W językach takich jak C++ czy Java, przekroczenie zakresu typu `int` (tzw. 'integer overflow') nie powoduje wyświetlenia błędu. Zazwyczaj liczba 'zawija się', czyli zaczyna liczyć od minimalnej wartości dla danego typu, co prowadzi do nieoczekiwanych i błędnych wyników."
    },
    {
      "question": "Ograniczeniem rekurencji jest wielkość pamięci stosu systemowego.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "To prawda. Każde rekurencyjne wywołanie funkcji odkłada na stosie jej kontekst (zmienne lokalne, adres powrotu). Zbyt głęboka rekurencja może prowadzić do przepełnienia stosu (stack overflow) i awarii programu."
    },
    {
      "question": "W większości języków programowania `string` jest tablicą znaków.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tak, fundamentalnie `string` (ciąg znaków) jest implementowany jako sekwencja lub tablica znaków. Wiele języków programowania pozwala na dostęp do poszczególnych znaków w stringu za pomocą indeksu, podobnie jak w tablicy."
    },
    {
      "question": "Tablica, jako struktura danych, ma tyle zalet, że jest najczęściej używanym sposobem przechowywania danych.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tablica jest jedną z najbardziej fundamentalnych i często używanych struktur danych dzięki prostocie i szybkiemu dostępowi do elementów przez indeks (złożoność O(1)). Jest podstawą dla wielu bardziej złożonych struktur."
    },
    {
      "question": "Dokładność obliczeń dla liczby typu `double` to 6 cyfr znaczących.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Liczba typu `double` (podwójnej precyzji) ma dokładność rzędu 15–17 cyfr znaczących. Typ `float` (pojedynczej precyzji) ma precyzję około 6–7 cyfr."
    },
    {
      "question": "Algorytm sortowania przez kopcowanie ma złożoność czasową O(n²).",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Sortowanie przez kopcowanie (Heapsort) ma złożoność czasową O(n log n) zarówno w przypadku średnim, jak i najgorszym, co czyni go znacznie wydajniejszym niż algorytmy o złożoności O(n²)."
    },
    {
      "question": "W notacji Big O, O(n²) + O(n log n) upraszcza się do O(n²).",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "W analizie złożoności obliczeniowej zachowujemy tylko składnik, który rośnie najszybciej. Ponieważ n² rośnie znacznie szybciej niż n*log(n), dominuje on całe wyrażenie. Dlatego to stwierdzenie jest prawdziwe."
    },
    {
      "question": "Stos jest typem listy.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Stos jest abstrakcyjnym typem danych, który można zaimplementować przy użyciu listy (lub tablicy). Działa on zgodnie z zasadą LIFO (Last-In, First-Out), co oznacza, że jest to lista z ograniczonymi operacjami."
    },
    {
      "question": "Sortowanie przez zliczanie wymaga utworzenia dodatkowej tablicy do zapisania posortowanych danych.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tak, sortowanie przez zliczanie jest algorytmem, który nie sortuje 'w miejscu'. Wymaga on co najmniej jednej dodatkowej tablicy (tablicy zliczeń) do przechowywania liczby wystąpień poszczególnych elementów, a często też osobnej tablicy wynikowej."
    },
    {
      "question": "Algorytm sortowania przez scalanie może być użyty, gdy dane nie mieszczą się w pamięci operacyjnej.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tak, algorytm sortowania przez scalanie (Merge Sort) jest podstawą dla tzw. sortowania zewnętrznego. Dane można podzielić na bloki mieszczące się w pamięci, posortować je, a następnie scalać w większe, posortowane bloki na dysku."
    },
    {
      "question": "Do sortowania danych tekstowych dobrym wyborem będzie algorytm sortowania kubełkowego.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tak, sortowanie kubełkowe (Bucket Sort) może być bardzo efektywne dla danych tekstowych, jeśli można je równomiernie rozłożyć na 'kubełki', np. na podstawie pierwszej litery słowa. Jest to szczególnie przydatne, gdy dane mają znany, ograniczony rozkład."
    },
    {
      "question": "Sortowanie stabilne zachowuje względną kolejność równych sobie elementów.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "To jest definicja sortowania stabilnego. Jeśli dwa elementy mają tę samą wartość (klucz sortowania), to po posortowaniu pojawią się w tej samej kolejności, w jakiej były w zbiorze wejściowym."
    },
    {
      "question": "Tablica jest strukturą danych rozproszoną w pamięci komputera.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Wręcz przeciwnie, tablica jest strukturą danych, której elementy są przechowywane w ciągłym bloku pamięci, jeden obok drugiego. Strukturami rozproszonymi są np. listy wiązane czy drzewa."
    },
    {
      "question": "Dwa algorytmy o tej samej złożoności O(n²) będą miały identyczny czas działania.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Notacja Big O opisuje tempo wzrostu czasu działania w zależności od rozmiaru danych, ignorując stałe czynniki. Dwa algorytmy o złożoności O(n²) mogą mieć różne stałe i w praktyce ich czasy działania będą się różnić, choć oba będą rosły kwadratowo."
    },
    {
      "question": "Istnieje algorytm sortowania o liniowej złożoności, ale wymaga on spełnienia dodatkowych warunków.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Tak, przykładami są sortowanie przez zliczanie (Counting Sort) lub sortowanie pozycyjne (Radix Sort). Działają one w czasie liniowym O(n), ale zakładają pewne właściwości danych, np. że są to liczby całkowite z ograniczonego zakresu."
    },
    {
      "question": "Przyjmuje się, że program jest poprawny, jeśli przechodzi wszystkie zaplanowane testy.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Przejście zaplanowanych testów jedynie zwiększa pewność, że program działa poprawnie, ale nie daje 100% gwarancji. Testy mogą nie pokrywać wszystkich przypadków brzegowych i nietypowych scenariuszy."
    },
    {
      "question": "Obliczenie n-tego wyrazu ciągu Fibonacciego metodą rekurencyjną ma złożoność O(n²).",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Naiwna implementacja rekurencyjna ma złożoność wykładniczą, około O(2ⁿ), a nie kwadratową. Wynika to z faktu, że wiele wartości jest obliczanych wielokrotnie. Złożoność kwadratową można osiągnąć np. metodą iteracyjną."
    },
    {
      "question": "Lista jest abstrakcyjnym modelem struktury danych i może być implementowana na różne sposoby.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Dokładnie tak. Lista jako typ abstrakcyjny definiuje operacje (np. dodaj, usuń, znajdź), a jej konkretna implementacja może być oparta na tablicy (ArrayList) lub na wskaźnikach (LinkedList)."
    },
    {
      "question": "Kolejka nie jest listą.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0,
      "explanation": "Kolejka, podobnie jak stos, jest abstrakcyjnym typem danych, który można zaimplementować za pomocą listy. Działa ona zgodnie z zasadą FIFO (First-In, First-Out). Jest to więc wyspecjalizowana forma listy z ograniczonymi operacjami."
    },
    {
      "question": "Najszybszy algorytm sortowania oparty na porównaniach ma złożoność O(n log n).",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Tak, udowodniono, że żaden algorytm sortowania oparty na porównaniach nie może mieć w najgorszym przypadku złożoności lepszej niż O(n log n). Algorytmy takie jak Merge Sort czy Heapsort osiągają ten limit."
    },
    {
      "question": "Jeśli algorytm ma złożoność O(n²), to gdy 'n' wzrośnie dwukrotnie, czas działania również wzrośnie dwukrotnie.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1,
      "explanation": "Jeśli 'n' wzrośnie dwukrotnie, czas działania algorytmu o złożoności O(n²) wzrośnie czterokrotnie (2² = 4). Zależność jest kwadratowa, a nie liniowa."
    },
    {
      "question": "Problem stopu, czyli rozstrzygnięcie, czy dowolny program zatrzyma się dla dowolnych danych, jest nierozstrzygalny.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "To prawda. Alan Turing udowodnił w 1936 roku, że nie istnieje uniwersalny algorytm, który byłby w stanie rozstrzygnąć dla każdego możliwego programu i jego danych wejściowych, czy ten program zakończy swoje działanie."
    },
    {
      "question": "Jeśli jeden algorytm ma złożoność O(n²), a inny O(n log n), to dla małych 'n' ten pierwszy może być szybszy.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "To prawda. Algorytm o złożoności O(n²) może mieć mniejszy stały czynnik, co sprawia, że dla małych zbiorów danych (małych 'n') może działać szybciej niż algorytm O(n log n), którego narzut na bardziej skomplikowaną logikę jest większy."
    },
    {
      "question": "Algorytm sortowania przez kopcowania ma złożoność O(n^2) ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Algorytm sortowania przez koksowanie hip sort ma złożoność O(n log n)."
    },
    {
      "question": "Aby określić graf trzeba podać zbiory i funkcję",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Aby określić graf należy podać zbiory wierzchołków i krawędzi oraz funkcję, która określa relację między wierzchołkami."
    },
    {
      "question": "Algorytm bisekcji służy do znajdowania maksimum funkcji",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Algorytm bisekcji służy do znajdowania pierwiastka równania lub miejsca zerowego funkcji"
    },
    {
      "question": "Algorytm iteracyjny wymaga podania warunków zatrzymania",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Algorytm numerycznej iteracji wymaga podania warunków zatrzymania, takich jak dokładność obliczenia lub maksymalna liczba iteracji."
    },
    {
      "question": "Algorytm iteracyjny zwykle daje rozwiązanie przybliżone",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Algorytm integracyjny daje rozwiązanie przybliżone, a nie dokładne. Imprecyjność wynika z faktu, że algorytm dzieli całkę na małe fragmenty, a następnie sumuje je, co jest tylko aproksymacją prawdziwej wartości."
    },
    {
      "question": "Algorytm iteracyjny często generuje nieskończony ciąg wyrazów",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Algorytm iteracyjny nigdy nie daje rozwiązania dokładnego ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Kluczem w tym zadaniu jest słowo “nigdy”, algorytm bisekcji podaje dokładne rozwiazanie na przykład"
    },
    {
      "question": "Algorytm Luhna obecnie nie jest stosowany, gdyż zakładam mnożenie przez 2, co prowadzi do braku sygnalizacji niektórych błędów",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Algorytm Luhna nadal jest często stosowany, szczególnie w branży finansowej do weryfikacji poprawności numerów kart kredytowych. Chociaż jest to prawda, że algorytm Luhna może nie wykryć wszystkich błędów."
    },
    {
      "question": "Algorytm Luhna szuka w grafie krawędzi o najmniejszej przypisanej wartości ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Algorytm Luhna nie jest algorytmem wyszukiwania w grafie. Jest to algorytm weryfikacji sumy kontrolnej stosowany do sprawdzania poprawności numerów kart kredytowych"
    },
    {
      "question": "Algorytmy iteracyjne opisują problemy ekonometryczne ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Tak, algorytmy iteracyjne mogą być stosowane do rozwiązywania problemów ekonometrycznych. Algorytmy iteracyjne mogą być wykorzystywane do prognozowania cen akcji lub innych wskaźników technicznych, do analizy wpływu wahania kursu walut na wyniki finansowe firmy lub do modelowania wpływu zmiany prawa podatkowego na płace pracowników."
    },
    {
      "question": "Algorytm Dijkstry służy do znajdowania najkrótszej ścieżki z pojedynczego źródła w grafie o nieujemnych wagach krawędzi",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Algorytm Luhna służy do sprawdzenia poprawności wpisania numeru, jest on używany m.in. do walidacji numerów kart kredytowych, ciągów liczbowych itd",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Algorytm Euklidesa służy do obliczania NWD(największego wspólnego dzielnika) dwóch liczb całkowitych ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Algorytm Euklidesa służy do znajdowania liczb pierwszych",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Cyfra kontrolna w powszechnie stosowanych numerach wykorzystuje dzielenie modulo ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Cyfry kontrolne potrafią znaleźć wszystkie błędy jakie może popełnić człowiek przy wprowadzaniu danych ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Czy kiedy mnożysz dwa wektory to wynik jest zawsze na tej samej płaszczyźnie ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Cyfry kontrolne stosowane są jedynie, gdy człowiek wprowadza ręcznie dane i nie ma potrzeby ich stosowania, gdy robią to urządzenia ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Cyfry kontrolne są stosowane zarówno przy ręcznym wprowadzaniu danych, jak i przy automatycznym wprowadzaniu danych przez urządzenia"
    },
    {
      "question": "Czy mnożenie dwóch wektorów jest prostą operacją matematyczną ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Cykl Eulera to ścieżka przechodząca dokładnie 1 raz przez każdą krawędź grafu",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Cykl Eulera to droga, w której wszystkie krawędzie występują dokładnie raz",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Cykl Eulera to droga w grafie, w której wszystkie krawędzie występują dokładnie raz. Aby istniał cykl Eulera, graf musi być Eulerowski, co oznacza, że w każdym wierzchołku stopień jest parzysty."
    },
    {
      "question": "Cykl Hamiltona to ścieżka przechodząca dokładnie raz przez każdy wierzchołek grafu ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Cykl Hamiltona to ścieżka w grafie, która przechodzi dokładnie raz przez każdy wierzchołek grafu i powraca do początkowego wierzchołka. To jest, cykl Hamiltona jest ścieżką, która tworzy pełen okrąg po grafie"
    },
    {
      "question": "Cykl Lebnica w grafie to droga łącząca wszystkie wierzchołki i przechodząca przez każdy dokładnie raz ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Nie ma pojęcia cyklu Lebnika w grafie. W terminologii grafów istnieją pojęcia takie jak cykl Eulera i cykl Hamiltona, ale nie ma pojęcia cyklu Lebnica."
    },
    {
      "question": "Cykl Pareto to ścieżka, do której należą wszystkie krawędzie grafu ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Cykl Pareto nie jest ścieżką w grafie. Cykl Pareto to koncepcja dotycząca ekonomii i zarządzania, która odnosi się do sytuacji, w której nie jest możliwe poprawienie jednego kryterium bez pogorszenia innego. W tej koncepcji nie ma pojęcia ścieżki w grafie."
    },
    {
      "question": "Często stosowanym sposobem modelowania grafu jest tablica, której elementami są listy wierzchołków ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Często stosowanym sposobem modelowania grafu jest tablica sąsiedztwa, w której każdy wierzchołek jest reprezentowany przez indeks w tablicy, a elementami tablicy są listy sąsiednich wierzchołków"
    },
    {
      "question": "Drzewo binarne może być Zamodelowane jako tablica jednowymiarowa",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "drzewo dwumianowe można zamodelować jako tablicę jednowymiarową. Ta technika nazywa się reprezentacją tablicową drzewa i polega na tym, że każdy węzeł drzewa jest przypisany do konkretnego indeksu w tablicy."
    },
    {
      "question": "Do szyfrowania dwuskładnikowego używa się szyfru niesymetrycznego z kluczem prywatnym i publicznym (RSA) ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Droga to to samo co ścieżka ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Fałsz(wedlug profesora Szepskiego)/ Prawda wedlug google"
    },
    {
      "question": "Euklides wymyślił pierwszy algorytm ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Graf możemy przeszukiwać wzdłuż i wszerz ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Grafem pełnym nazywamy graf, w którym każde dwa wierzchołki są ze sobą połączone krawędzią ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Istnieje graf, który jest drzewem i ma cykl ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Graf, który jest drzewem, nie może mieć cyklu. W drzewie nie istnieją żadne powtarzające się ścieżki, co oznacza, że nie można powrócić do żadnego wierzchołka po jego już odwiedzeniu."
    },
    {
      "question": "Istnieją algorytmy iteracyjne znajdujące miejsca zerowe funkcji ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Algorytm bisekcji"
    },
    {
      "question": "Istota algorytmów szyfrowania z kluczem publicznym i prywatnym. Oparta jest na dużym czasie obliczeń potrzebnych do złamania klucza prywatnego",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Jeśli graf ma 12 wierzchołków i 11 krawędzi, to jest drzewem ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Graf z 12 wierzchołkami i 11 krawędziami nie jest drzewem. W drzewie każdy wierzchołek ma dokładnie jednego rodzica, oprócz korzenia, który nie ma rodzica. Tym samym, drzewo o n wierzchołkach ma n-1 krawędzie. Graf z 12 wierzchołkami i 11 krawędziami ma więcej krawędzi niż jest to konieczne, aby być drzewem, co oznacza, że istnieje co najmniej jeden cykl w grafie."
    },
    {
      "question": "Jeżeli graf ma 12 wierzchołków i 10 krawędzi, to jest grafem spójnym ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Jednym z podstawowych algorytmów szukania punktu jest algorytm przeszukiwania przestrzeni ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Jeżeli graf ma 13 wierzchołków i 12 krawędzi, i jest spójny, to jest drzewem ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Niekoniecznie. Graf, który jest spójny i ma 13 wierzchołków i 12 krawędzi, może być drzewem, ale może też nim nie być"
    },
    {
      "question": "Najlepszy sposób przeszukiwania grafu to przeszukiwanie wszerz",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Przeszukiwanie wszerz (BFS, Breadth First Search) jest dobre do znajdowania najkrótszej ścieżki między dwoma wierzchołkami, ale może nie być najlepsze do rozwiązywania innych problemów"
    },
    {
      "question": "Przeszukiwanie grafów w głąb jest lepsze niż wszerz ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "To zależy od kontekstu i celu przeszukiwania. Każdy z tych algorytmów jest lepszy w różnych sytuacjach"
    },
    {
      "question": "Rząd grafu to liczba wierzchołków w grafie ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Rozmiar grafu to liczba krawędzi w grafie ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Stopień wierzchołka jest zawsze parzysty ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "W zależności od typu grafu i liczby krawędzi łączących dany wierzchołek, stopień wierzchołka może być parzysty lub nieparzysty."
    },
    {
      "question": "Sito Eratostenesa służy do obliczenia NWD(największego wspólnego dzielnika) ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Sito Eratostenesa nie służy do obliczania NWD (największego wspólnego dzielnika). Sito Eratostenesa to algorytm służący do znajdowania wszystkich liczb pierwszych mniejszych lub równych danej liczbie. Natomiast NWD oblicza się za pomocą algorytmu Euklidesa"
    },
    {
      "question": "Szyfr niesymetryczny z kluczem prywatnym i publicznym jest podstawą podpisu elektronicznego ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Sito Eratostenesa jest algorytmem, który szybko znajduje wszystkie liczby pierwsze z przedziału ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "W grafie skierowanym krawędź jest określona przez parę wierzchołków ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "W grafie suma wszystkich wierzchołków jest zawsze parzysta ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "Suma wierzchołków grafu nie jest zawsze parzysta. To zależy od liczby wierzchołków i krawędzi w grafie."
    },
    {
      "question": "W grafie wierzchołki mają zawsze przypisane wartości ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "W pamięci komputera graf może być opisany jako tablica dwuwymiarowa, wiążąca wierzchołki i krawędzie ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Graf może być opisany jako tablica dwuwymiarowa, wiążąca wierzchołki i krawędzie. Jest to jedna z form reprezentacji grafów, zwaną macierzą incydencji."
    },
    {
      "question": "W wielu algorytmach geometrycznych wykorzystywany jest iloczyn wektorów na podstawie którego określa się wzajemne położenie punktów na płaszczyźnie ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "W wielu algorytmach geometrycznych wykorzystywany jest iloczyn wektorów, aby określić wzajemne położenie punktów na płaszczyźnie. Iloczyn ten jest często używany do obliczania takich wartości jak kąty między wektorami, detekcja kolizji między obiektami i wiele innych."
    },
    {
      "question": "Wyznaczanie punktów tworzących wypukłą otoczkę zbioru punktów na płaszczyźnie pozwala wyeliminować punkty leżące wewnątrz wielokąta ",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "Tak, wyznaczanie punktów tworzących wypukłą otoczkę zbioru punktów na płaszczyźnie pozwala wyeliminować punkty leżące wewnątrz wielokąta. Wypukła otoczka jest zdefiniowana jako najmniejszy wypukły wielokąt zawierający wszystkie punkty z danego zbioru."
    },
    {
      "question": "Zbiór wierzchołków i zbiór krawędzi z określeniem, które wierzchołki łączy dana krawędź definiuje graf",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Sortowanie w miejscu oznacza, że",
      "answers": ["Sortowanie jest dokonywane na komputerze klasy PC", "Dane do posortowania są zapisane w tablicy w pamięci komputera","zadanie sortowania nie jest dokładnie określone i programista musi dopisać","sortowanie odbywa się lokalnie w miejscu pracy programisty"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Jeśli algorytm sortowania jest stabilny, oznacza to że",
      "answers": ["Czas sortowania nie zależy od typu sortowanych elementów", "Czas sortowania nie zależy jak są uporządkowane elementy przed sortowaniem","Jeśli elementy a i b są równe i przed sortowaniem element a znajdował się przed b to po sortowaniu ich kolejność nie zmienia się","Innymi słowy, stabilne sortowanie nie zmienia wzajemnej kolejności równych elementów"],
      "correct": 2, 
      "explanation": "Innymi słowy, stabilne sortowanie nie zmienia wzajemnej kolejności równych elementów"
    },
    {
      "question": "Mnożenie dwóch liczb n cyfrowych metodą pisemną (tzn. tak jak uczono w szkole) jest",
      "answers": ["O(n^2)", "O(n^3)","O(n)","O(n lg n)"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Ciąg Fibonacciego występuje w matematyce często w wielu różnych problemach. Obliczenie wartości w… pomocą różnych algorytmów",
      "answers": ["Obliczenie wartości nawet kilku pierwszych wyrazów ciągu Fibonacciego wymaga użycia specjalnych typów zmiennych", "Obliczenie wartości elementów ciągu Fibonacciego metodą iteracyjną jest szybkie","Nie ma różnicy jaki algorytm zastosujemy, obliczenie nawet dużych (czyli dalekich) wyrazów nie nastręcza trudności","Obliczenie wartości elementów ciągu Fibonacciego metodą rekurencyjną jest najłatwiejsze i szybkie"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Zapis liczby 238 456 000 000 w notacji naukowej (tzn. potęgowej z symbolem e) będzie miał postać",
      "answers": ["236456e+6", "2,36456e+11","0,236456e+12","Każdy powyższy sposób jest poprawny, a sposób wyświetlenia zależy od kompilatora"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Algorytmy sortowanie często używają dwóch funkcji: funkcji porównujących elementy a[i] oraz a[j] i funkcji zmieniającej miejscami te elementy w tablicy",
      "answers": ["Algorytmy które nie porównują elementów, często dają złe wyniki sortowania", "Takie algorytmy sortowania są najszybsze","Wszystkie algorytm sortowania, porównują elementy i je przestawiają","Takie algorytmy mają złożoność obliczeniową co najmniej O(n lg n) , szybszy algorytm musi zrezygnować z porównań między elementami"],
      "correct": 3, 
      "explanation": "szybszy algorytm musi zrezygnować z porównań między elementami i wykorzystywać inne techniki, takie jak zliczanie wystąpień (sortowanie kubełkowe, radix sort), które działają tylko dla określonych typów danych (np. liczb całkowitych z ograniczonego zakresu)."
    },
    {
      "question": "Wieże Hanoi to problem, którego rozwiązanie wymaga",
      "answers": ["O(n^2) działań", "O(2^n) działań","O(n!) działań","O(n lg(n)) działań"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "W posortowanym ciągu n elementowym znajdziemy element o określonym kluczu maksymalnie w:",
      "answers": ["n krokach", "n^2 krokach","lg n krokach","n/2 krokach"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Włosy na głowie rosną z prędkością około (w przybliżeniu):",
      "answers": ["0.1389 e+4km/h", "0.00001389 km/h","1389 e-8 km/h","1.4 e-8 km/h"],
      "correct": 3, 
      "explanation": ""
    },
    {
      "question": "Czym różni się kolejka od stosu?",
      "answers": ["Kolejnością usuwania elementów z listy", "Kolejka jest strukturą powiązaną a stos tablicą","Kolejka jest strukturą ogólniejszą niż stos","Niczym, są to takie same implementacje listy"],
      "correct": 0, 
      "explanation": ""
    },
    {
      "question": "Najbardziej precyzyjnym sposobem algorytmu jest",
      "answers": ["Graficzne przedstawienie algorytmu", "Opowiedzenie ze szczegółami jak działa algorytm","Pseudokod","Kod programu w języku programowania"],
      "correct": 3, 
      "explanation": ""
    },
    {
      "question": "Jeśli mamy do dyspozycji dwa algorytmy: pierwszy o złożoności O(n lg n) i drugi o złożoności O(n2) to:",
      "answers": ["Dla dostatecznie dużych wartości n lepszy jest algorytm pierwszy, ale dla małych wartości n tak być nie musi, trzeba wtedy przeanalizować stałe ukryte w notacji asymptotycznej oraz przetestować oba algorytmy w praktyce", "lgorytm o wyższej złożoności może działać szybciej dla małych danych, jeśli ma prostszą strukturę lub mniejszy narzut czasowy","Różnica między nimi jest niewielka i nie ma znaczenia, który algorytm zastosujemy","Pierwszy algorytm jest lepszy i należy go zawsze stosować"],
      "correct": 0, 
      "explanation": "Algorytm o wyższej złożoności może działać szybciej dla małych danych, jeśli ma prostszą strukturę lub mniejszy narzut czasowy."
    },
    {
      "question": "Algorytmy sortowania sortują tylko tablice liczb całkowitych lub rzeczywistych",
      "answers": ["Nie, bo mogą sortować także liczby zespolone", "Tak, bo tylko liczby można ze sobą porównywać","Nie, mogą sortować tablice, których elementami są rekordy","Tak-bo w tablicy można przechowywać jedynie liczbowe typy proste"],
      "correct": 2, 
      "explanation": ""
    },
     {
      "question": "Algorytm można przedstawić graficznie w postaci schematu blokowego lub diagramu czynności UML",
      "answers": ["Schemat blokowy i diagram czynności UML, nie mają ze sobą nic wspólnego", "Diagram czynności UML jest ogólniejszy, powstał dlatego, że niektórych algorytmów nie da się przedstawić jako schemat blokowy.","Schemat blokowy jest ogólniejszy niż diagram czynności UML","Nie ma znaczenia, który diagram wybierzemy, zawsze będą one do siebie podobne"],
      "correct": 2, 
      "explanation": ""
    },
      {
      "question": "Schemat Honera służy do",
      "answers": ["Dzielenia wielomianów", "Obliczania wartości funkcji Silnia","Obliczania wartości dowolnej funkcji w punkcie x=0","Obliczania wartości wielomianu"],
      "correct": 3, 
      "explanation": ""
    },
      {
      "question": "Przykładami algorytmów sortowania o złożoności O(n2) są",
      "answers": ["Sortowanie przez wybieranie i sortowanie przez proste wstawianie", "Sortowanie kubełkowe i sortowanie przez zliczanie","Sortowanie przez kopcowanie i sortowanie przez łączenie","sortowanie przez proste wstawiania i sortowanie szybki"],
      "correct": 0, 
      "explanation": ""
    },
      {
      "question": "Algorytm szybkiego sortowania, QuickSort, jest zawsze szybszy niż inne algorytmy sortowania elementów",
      "answers": ["Nie, opinia, że jest to szybki algorytm nie znajduje potwierdzenia w eksperymentach", "Algorytm QuickSort ma złożoność O(n lg n) i bardzo podobny czas działania do innych algorytmów o takiej złożoności w przypadku danych losowych, jednak w najgorszym przypadku jego złożoność spada do O(n²), dlatego ważny jest odpowiedni wybór pivota.","Często, ale znane są przyklady, że inne algorytmy są szybsze","Tak"],
      "correct": 1, 
      "explanation": ""
    },
    {
      "question": "Liczby pierwsze są ważne ponieważ",
      "answers": ["Jako pierwsze są przed innymi liczbami", "Tak było kiedyś, ale w czasach komputerowych straciły na znaczeniu","Były pierwsze w historii i od nich zaczęła się matematyka i informatyka","Są używane w niektórych, bardzo ważnych algorytmach"],
      "correct": 3, 
      "explanation": ""
    },

    {
      "question": "Czas rozwiązania problemu jest ważny, dlatego:",
      "answers":["wszystkie znane algorytmy maja krótki czas wykonania","współczesne komputery są tak szybkie, że czas rozwiązania problemu...","zawsze zależy nam aby złozoność obliczeniowa algorytmu była jak najmniejsza","zwykle dążymy do tego aby złożoność była jak najmniejsza, ale istnieją ... największy"],
      "correct":[2,3],
      "explanation": ""
    }

  ],






  "makroekonomia": [
     {
      "question": "Wartość dodaną oblicza się przez odjęcie od wartości dóbr wyprodukowanych w przedsiębiorstwie sumy kosztów rzeczowych czynników wytwórczych zużytych do produkcji tych dóbr.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "M. Bałut, M. Pelikan-Krupińska, J. Świerczyńska, Podstawy makroekonomii. Ćwiczenia, Kraków 2007"
    },
    {
      "question": "Jeżeli kupujesz używany rower, zostaje to uwzględnione w PKB.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "M. Bałut, M. Pelikan-Krupińska, J. Świerczyńska, Podstawy makroekonomii. Ćwiczenia, Kraków 2007"
    },
    {
      "question": "Do PKB nie wlicza się przelewów finansowych pomiędzy filiami korporacji międzynarodowej.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 0, 
      "explanation": "M. Bałut, M. Pelikan-Krupińska, J. Świerczyńska, Podstawy makroekonomii. Ćwiczenia, Kraków 2007"
    },
    {
      "question": "Wydatki firmy X na długopisy, meble i olej napędowy należą do wydatków konsumpcyjnych.",
      "answers": ["Prawda", "Fałsz"],
      "correct": 1, 
      "explanation": "M. Bałut, M. Pelikan-Krupińska, J. Świerczyńska, Podstawy makroekonomii. Ćwiczenia, Kraków 2007"
    }
  ],





  "bazy danych": [
    {
      "question": "Za autoryzację dostępu do bazy danych odpowiada",
      "answers": ["tabela users w bazie danych", "System Zarządzania Bazą danych","system operacyjny serwera","aplikacja kliencka"],
      "correct": [1],
      "explanation": "System Zarządzania Bazą Danych (SZBD/DBMS), taki jak np. MySQL, PostgreSQL czy Oracle, jest oprogramowaniem, które ma wbudowane mechanizmy do uwierzytelniania (sprawdzania, kim jest użytkownik) i autoryzacji (sprawdzania, co dany użytkownik może robić). To on, po otrzymaniu zapytania, weryfikuje uprawnienia użytkownika i decyduje, czy zezwolić na dostęp do danych, czy go zablokować. ---Tabela users w bazie danych przechowuje jedynie informacje o użytkownikach i ich uprawnieniach. SZBD korzysta z tej tabeli, ale to on jest aktywnym systemem, który egzekwuje te reguły.---System operacyjny serwera kontroluje dostęp do samego serwera i plików, ale nie zarządza uprawnieniami wewnątrz bazy danych.---Aplikacja kliencka jest tylko pośrednikiem; wysyła żądania do bazy danych, ale ostateczną decyzję o autoryzacji podejmuje SZBD."
    },
    {
      "question": "Postać normalna, w której wymaga się tylko aby żaden atrybut w tabeli nie był podzielny dalej to:",
      "answers": ["druga postać normalna", "postać normalna Beyoce'a-Codda","trzecia postać normalna","pierwsza postać normalna"],
      "correct": [3],
      "explanation": "Pierwsza postać normalna (1NF) to podstawowy poziom normalizacji bazy danych. Jej jedynym wymogiem jest to, aby wszystkie atrybuty (wartości w kolumnach) były atomowe, czyli niepodzielne. Oznacza to, że pojedyncza komórka w tabeli nie może zawierać wielokrotnych wartości (np. listy czy zbioru)."
    },
  {
    "question": "Co to jest baza danych?",
    "answers": [
      "Zbiór narzędzi do zarządzania aplikacjami.",
      "Zbiór informacji opisujący wybrany fragment rzeczywistości.",
      "System operacyjny do przechowywania plików.",
      "Program do tworzenia dokumentów tekstowych."
    ],
    "correct": [1],
    "explanation": "Baza danych to zbiór informacji opisujący wybrany fragment rzeczywistości. Np. dla sklepu: dane dotyczące klientów, towarów, faktur; dla banku: dane klientów, ich rachunków, operacji na rachunkach[cite: 6]."
  },
  {
    "question": "Jaka jest podstawowa funkcjonalność Systemu Zarządzania Bazą Danych (SZBD)?",
    "answers": [
      "Tworzenie stron internetowych.",
      "Zarządzanie całą bazą danych oraz realizowanie żądań aplikacji użytkowników.",
      "Edycja zdjęć i grafik.",
      "Wysyłanie wiadomości e-mail."
    ],
    "correct": [1],
    "explanation": "Z technologicznego punktu widzenia SZBD jest to moduł programowy, którego zadaniem jest zarządzanie całą bazą danych oraz realizowanie żądań aplikacji użytkowników[cite: 22]."
  },
  {
    "question": "Co oznacza 'trwałość danych' w kontekście baz danych?",
    "answers": [
      "Dane są przechowywane tymczasowo, tylko podczas działania aplikacji.",
      "Dane mogą być łatwo usunięte przez użytkownika.",
      "Dane przechowywane w bazie danych nie są ulotne i są niezależne od działania aplikacji oraz platformy sprzętowo-programowej.",
      "Dane są dostępne tylko dla jednego użytkownika jednocześnie."
    ],
    "correct": [2],
    "explanation": "Trwałość danych oznacza, że dane przechowywane w bazie danych nie są ulotne. Okres przechowywania danych jest ograniczony wyłącznie okresem żywotności nośnika danych. [cite_start]'Czas życia' danych, po ich zapisaniu do bazy danych jest niezależny od istnienia i działania bądź niedziałania aplikacji, a także od platformy sprzętowo-programowej[cite: 73, 74, 75, 76]."
  },
  {
    "question": "Który z wymienionych elementów jest częścią procesora zapytań w DBMS?",
    "answers": [
      "Moduł zarządzania transakcjami.",
      "Menedżer pamięci.",
      "Kompilator zapytań.",
      "Moduł bezpieczeństwa sieci."
    ],
    "correct": [2],
    "explanation": "Procesor zapytań składa się m.in. z kompilatora zapytań, który tłumaczy zapytanie na postać wewnętrzną[cite: 41]."
  },
  {
    "question": "Co definiuje 'schemat bazy danych'?",
    "answers": [
      "Sposób, w jaki dane są wyświetlane użytkownikowi.",
      "W jaki sposób dane są przechowywane na dysku.",
      "W jaką powinna być struktura danych oraz w jaki sposób dane są powiązane.",
      "Zbiór predefiniowanych operacji na danych."
    ],
    "correct": [2],
    "explanation": "Schemat baz danych określa w jaka powinna być struktura danych oraz w jaki sposób dane są powiązane[cite: 9]."
  },
  {
    "question": "Czym są metadane w kontekście baz danych?",
    "answers": [
      "Dane przechowywane na nośnikach zewnętrznych.",
      "Dane, które opisują dane przechowywane w bazie, ich struktury, użytkowników i uprawnienia.",
      "Ulotne informacje generowane przez aplikacje.",
      "Informacje o wydajności systemu operacyjnego."
    ],
    "correct": [1],
    "explanation": "Metadane to najprościej mówiąc dane o bazie danych. [cite_start]Dane te opisują m.in.: dane przechowywane w bazie, struktury danych, użytkowników i ich uprawnienia, relacje między obiektami, dane o archiwizacji itp.[cite: 124, 125]."
  },
  {
    "question": "Który z modeli danych jest najczęściej stosowany w nowo budowanych systemach baz danych?",
    "answers": [
      "Model hierarchiczny.",
      "Model obiektowo-relacyjny.",
      "Model relacyjny.",
      "Model semistrukturalny."
    ],
    "correct": [1,2,3],
    "explanation": "Obecnie w bazach danych najczęściej stosuje się model relacyjny, obiektowo-relacyjny lub semistrukturalny[cite: 136]."
  },
  {
    "question": "Jaka grupa użytkowników SBD jest odpowiedzialna za przygotowanie systemu do pracy produkcyjnej i zarządzanie użytkownikami?",
    "answers": [
      "Analitycy systemowi.",
      "Programiści aplikacji.",
      "Użytkownicy końcowi.",
      "Administratorzy systemów baz danych."
    ],
    "correct": [3],
    "explanation": "Administratorzy systemu bazy danych są odpowiedzialni m.in. za przygotowanie systemu do pracy produkcyjnej, zagwarantowanie ciągłości pracy systemu oraz zarządzanie użytkownikami[cite: 194, 195, 196]."
  },
  {
    "question": "Język SQL jest językiem deklaratywnym. Co to oznacza?",
    "answers": [
      "Specyfikuje tylko co chcemy otrzymać, nie specyfikuje sposobu, w jaki ma być zrealizowane zadanie.",
      "Umożliwia tworzenie graficznych interfejsów użytkownika.",
      "Wymaga szczegółowego opisu algorytmów wykonania zadań.",
      "Służy do programowania aplikacji na niskim poziomie."
    ],
    "correct": [0],
    "explanation": "SQL jest językiem deklaratywnym. [cite_start]Oznacza to, że posługując się nim specyfikujemy tylko co chcemy otrzymać, nie specyfikujemy sposobu (algorytmu) w jaki ma być zrealizowane zadanie[cite: 201]."
  },
  {
    "question": "Co jest zadaniem 'Menedżera pamięci' w DBMS?",
    "answers": [
      "Tłumaczenie zapytań na postać wewnętrzną.",
      "Sterowanie umieszczaniem danych na dysku oraz przesyłaniem danych między dyskiem i pamięcią.",
      "Zapewnianie bezpieczeństwa danych w przypadku awarii sprzętowo-programowej.",
      "Tworzenie struktury drzewa z zapytania."
    ],
    "correct": [1],
    "explanation": "Menedżer pamięci steruje umieszczaniem danych na dysku oraz przesyłaniem danych między dyskiem i pamięcią[cite: 48]."
  },
  {
    "question": "Które z poniższych stwierdzeń prawidłowo opisują cel modelowania związków encji?",
    "answers": [
      "Dostarczenie modelu niezależnego od sposobu przechowywania danych i metod dostępu do nich.",
      "Ułatwienie komunikacji między projektantami, programistami i użytkownikami dzięki jednoznacznemu i mało technicznemu modelowi.",
      "Automatyczne generowanie kodu aplikacji bazodanowych.",
      "Dostarczenie dokładnego modelu potrzeb informacyjnych przedsiębiorstwa, który stanowiłby podstawę do konstruowania nowych lub ulepszonych systemów."
    ],
    "correct": [0, 1, 3],
    "explanation": "Modelowanie związków encji ma na celu dostarczenie dokładnego modelu potrzeb informacyjnych przedsiębiorstwa, który stanowiłby podstawę do konstruowania nowych lub ulepszonych systemów, oraz dostarczenie modelu niezależnego od sposobu przechowywania danych i od metod dostępu do nich, umożliwiającego podejmowanie celowych decyzji, jeśli chodzi o metod implementacyjne i współdziałanie z istniejącymi systemami. [cite: 28, 29] [cite_start]Dodatkowo, jest to metoda pozwalająca uzyskać model, który musi być jednoznaczny, a przy tym mało techniczny, który byłby zrozumiały dla wszystkich, którzy uczestniczą w tworzeniu bazy. [cite: 14]"
  },
  {
    "question": "Jakie elementy zawiera model danych w postaci diagramu związków encji (ERD)?",
    "answers": [
      "Diagramy przepływu danych.",
      "Encje.",
      "Atrybuty.",
      "Związki."
    ],
    "correct": [1, 2, 3],
    "explanation": "Model danych w postaci diagramu związków encji zawiera trzy rodzaje elementów: encje, atrybuty oraz związki. [cite: 34, 35, 36, 37]"
  },
  {
    "question": "Co jest prawidłową reprezentacją graficzną encji w diagramie związków encji (ERD)?",
    "answers": [
      "Owal z nazwą encji.",
      "Ramka (prostokąt o zaokrąglonych rogach) z umieszczoną w środku nazwą encji pisaną wielkimi literami w liczbie pojedynczej.",
      "Linia łącząca dwie encje.",
      "Kwadrat z atrybutami."
    ],
    "correct": [1],
    "explanation": "Reprezentacją graficzną encji jest ramka (prostokąt o zaokrąglonych rogach) z umieszczoną w środku nazwą encji. [cite_start]Nazwa powinna być pisana w liczbie pojedynczej i napisana wielkimi literami. [cite: 40, 41]"
  },
  {
    "question": "Które z poniższych są regułami dotyczącymi encji?",
    "answers": [
      "Wszystkie encje mogą się częściowo pokrywać.",
      "Każda encja musi być jednoznacznie identyfikowalna.",
      "Nazwa encji musi dokładnie reprezentować typ lub klasę rzeczy, a nie jakąkolwiek jej instancję.",
      "Wszystkie encje się wzajemnie wykluczają."
    ],
    "correct": [1, 2, 3],
    "explanation": "Reguły dotyczące encji mówią, że nazwa encji musi dokładnie reprezentować typ lub klasę rzeczy - a nie jakąkolwiek jej instancję[cite: 48]. [cite_start]Wszystkie encje się wzajemnie wykluczają, tzn. iż każdy przedmiot lub rzecz może być reprezentowany tylko przez jedną encję[cite: 51]. Każda encja musi być jednoznacznie identyfikowalna, tzn. [cite_start]że każda instancja (wystąpienie) encji musi być wyraźnie odróżnialna od wszystkich innych instancji tego typu encji[cite: 52]."
  },
  {
    "question": "Które z poniższych stwierdzeń są prawdziwe w odniesieniu do związków w diagramie ERD?",
    "answers": [
      "Są zbiorem istotnych powiązań pomiędzy zbiorami encji.",
      "Reprezentacją graficzną związku jest trójkąt.",
      "Każdy związek ma przypisaną nazwę, stopień i opcjonalność (opcjonalny/wymagany).",
      "Mogą być powiązaniem tej samej encji ze sobą (rekurencyjnie)."
    ],
    "correct": [0, 2, 3],
    "explanation": "Związki – to zbiór istotnych powiązań pomiędzy zbiorami encjami[cite: 54]. [cite_start]Każdy związek ma przypisaną nazwę, stopień i opcjonalność[cite: 61, 62, 63, 64, 65]. [cite_start]W szczególnym przypadku związek może być powiązaniem tej samej encji ze sobą[cite: 56]. [cite_start]Reprezentacją graficzną związku jest linia (krzywa) łącząca ze sobą dwie ramki encji lub rekurencyjnie jedną ramkę ze sobą[cite: 59, 60]."
  },
  {
    "question": "Jakie są cechy atrybutu jednowartościowego?",
    "answers": [
      "Może przyjmować wiele wartości dla pojedynczego wystąpienia encji.",
      "Przyjmuje tylko jedną wartość dla każdego wystąpienia encji.",
      "Jest wyliczany z podobnego atrybutu lub ze zbioru atrybutów.",
      "Przykładowo, dla każdego wystąpienia encji KINO atrybut kodkina ma pojedynczą wartość."
    ],
    "correct": [1, 3],
    "explanation": "Atrybut jednowartościowy przyjmuje tylko jedną wartość dla każdego wystąpienia encji. [cite: 98] Przykładowo, dla każdego wystąpienia encji KINO atrybut kodkina ma pojedynczą wartość np. [cite_start]SC001 i z tego powodu atrybut kodkina jest jednowartościowy. [cite: 99]"
  },
  {
    "question": "Które z poniższych poprawnie opisują 'kurzą stopkę' (crowsfoot) w diagramach ERD?",
    "answers": [
      "Jest to graficzna reprezentacja atrybutu pochodnego.",
      "Symbolizuje liczebność 'wiele' w związku encji.",
      "Linia związku dotyka ramki przedstawiającej encję w trzech punktach.",
      "Jest to stosowane, gdy związek jest opcjonalny."
    ],
    "correct": [1, 2],
    "explanation": "Przy liczebności „wiele linia związku dotyka ramki przedstawiającej encję w trzech punktach. Połączenie to nosi nazwę „kurzej stopki\" (ang. crowsfoot). [cite: 73]"
  },
  {
    "question": "Jaka jest graficzna reprezentacja atrybutu w diagramie związków encji?",
    "answers": [
      "Owal umieszczony poza ramką encji.",
      "Linia łącząca ramkę encji z inną ramką encji.",
      "Wpisanie jego nazwy w liczbie pojedynczej, małymi literami, w ramkę encji.",
      "Trójkąt obok nazwy encji."
    ],
    "correct": [2],
    "explanation": "Aby w sposób graficzny przedstawić atrybut w diagramie, należy w ramkę encji wpisać małymi literami jego nazwę w liczbie pojedynczej. [cite: 93]"
  },
  {
    "question": "Które z poniższych stwierdzeń są prawdziwe odnośnie atrybutów pochodnych?",
    "answers": [
      "Ich wartość jest bezpośrednio przechowywana w bazie danych.",
      "Są wyliczane z innych atrybutów, niekoniecznie z tego samego zbioru encji.",
      "Są zawsze jednowartościowe.",
      "Przykładem jest 'czas realizacji zamówienia' wyliczony jako różnica daty złożenia i wysyłki."
    ],
    "correct": [1, 3],
    "explanation": "Atrybut pochodny to atrybut reprezentujący wartość, która jest wyliczana z podobnego atrybutu lub ze zbioru atrybutów, niekoniecznie pochodzącego z tego samego zbioru encji. [cite: 103] [cite_start]Przykładowo, czas realizacji zamówienia (liczba dni), jaki upłynął od złożenia zamówienia przez klienta do momentu wysyłki zamówienia może być wyliczony jako różnica tych dat. [cite: 104]"
  },
  {
    "question": "Które z poniższych pojęć są podstawowymi elementami relacyjnej bazy danych?",
    "answers": [
      "Tabela",
      "Pole (atrybut)",
      "Rekord (krotka)",
      "Związek (więź)"
    ],
    "correct": [0, 1, 2, 3],
    "explanation": "Relacyjną bazą danych nazywamy bazę danych w postaci tabel połączonych relacjami. Podstawowe pojęcia to: Tabela (encja – relacja - klasa), Pole (atrybut - kolumna), Rekord (krotka - obiekt (instancja klasy) – wiersz) oraz Związek (więź - asocjacja)."
  },
  {
    "question": "Czym jest 'relacja' w kontekście relacyjnych baz danych?",
    "answers": [
      "Zbiorem aplikacji do zarządzania danymi.",
      "Skończonym zbiorem krotek (rekordów).",
      "Podzbiorem iloczynu kartezjańskiego dwóch wybranych zbiorów reprezentujących dopuszczalne wartości.",
      "Graficznym przedstawieniem zależności między tabelami."
    ],
    "correct": [1, 2],
    "explanation": "Podstawową strukturą danych jest relacja będąca podzbiorem iloczynu kartezjańskiego dwóch wybranych zbiorów reprezentujących dopuszczalne wartości. Relacja to skończony zbiór krotek (rekordów)."
  },
  {
    "question": "Które z poniższych stwierdzeń prawidłowo opisują 'klucz relacji'?",
    "answers": [
      "Klucz relacji to zbiór, którego każdy podzbiór jest zbiorem identyfikującym relacji.",
      "Klucz relacji to taki zbiór identyfikujący relacji, którego żaden podzbiór nie jest zbiorem identyfikującym relacji.",
      "Klucz jest kluczem prostym, jeśli zbiór identyfikujący relacji jest zbiorem jednoelementowym.",
      "Klucz podstawowy to pole, za pomocą którego rekord jest jednoznacznie identyfikowany w tabeli."
    ],
    "correct": [1, 2, 3],
    "explanation": "Klucz relacji to taki zbiór identyfikujący relacji, którego żaden podzbiór nie jest zbiorem identyfikującym relacji. Wyróżnia się klucze proste i złożone. Klucz jest kluczem prostym, jeśli zbiór identyfikujący relacji jest zbiorem jednoelementowym. Aby w bazie możliwe było szybkie wyszukiwanie i łączenie danych z tabel, każdy rekord tabeli powinien zawierać pole za pomocą którego byłby jednoznacznie identyfikowany w bazie. Pole tego typu nazywamy kluczem podstawowym."
  },
  {
    "question": "Zgodnie z postulatami Codd'a, które z poniższych są prawdziwe odnośnie dostępu do danych i wartości NULL?",
    "answers": [
      "Każda wartość w bazie danych jest dostępna tylko poprzez nazwę tabeli.",
      "Każda wartość w bazie danych jest dostępna poprzez podanie nazwy tabeli, atrybutu oraz wartości klucza podstawowego.",
      "Wartość NULL służy do reprezentacji tylko wartości nieokreślonej.",
      "Dostępna jest specjalna wartość NULL dla reprezentacji wartości nieokreślonej jak i nieadekwatnej, inna od wszystkich i podlegająca przetwarzaniu."
    ],
    "correct": [1, 3],
    "explanation": "Postulat dostępu mówi, że każda wartość w bazie danych jest dostępna poprzez podanie nazwy tabeli, atrybutu oraz wartości klucza podstawowego[cite: 51]. [cite_start]Postulat dotyczący wartości NULL mówi, że dostępna jest specjalna wartość NULL dla reprezentacji wartości nieokreślonej jak i nieadekwatnej, inna od wszystkich i podlegająca przetwarzaniu[cite: 52]."
  },
  {
    "question": "Które z poniższych to typy więzi (związków) w relacyjnej bazie danych?",
    "answers": [
      "Więź jeden-do-jeden.",
      "Więź jeden-do-wielu.",
      "Więź wiele-do-wielu.",
      "Więź typu 'drzewo'."
    ],
    "correct": [0, 1, 2],
    "explanation": "Więzi to powiązania pomiędzy parą tabel (relacji). Istnieją więzi: jeden-do-jeden, jeden-do-wielu oraz wiele-do-wielu."
  },
  {
    "question": "Które z poniższych typów złączeń (join) są wymienione w prezentacji?",
    "answers": [
      "Złączenie naturalne.",
      "Złączenie zewnętrzne typu union.",
      "Złączenie teta.",
      "Złączenie krzyżowe."
    ],
    "correct": [0, 1, 2],
    "explanation": "W prezentacji wymieniono następujące typy związków/złączeń: iloczyn kartezjański, złączenie naturalne, złączenie wewnętrzne (inner join), złączenie zewnętrzne lewostronne (left outer join) i prawostronne (right outer join), złączenie zewnętrzne typu union oraz złączenie teta."
  },
  {
    "question": "Co jest charakterystyczne dla złączenia naturalnego?",
    "answers": [
      "Polega na połączeniu w pary tych krotek, które mają identyczne wartości dla wszystkich wspólnych atrybutów.",
      "W rezultacie powstaje relacja, której schemat zawiera atrybuty obu relacji, a wspólna część jest uwzględniana tylko raz.",
      "Łączy dwie relacje w iloczyn kartezjański i wybiera krotki spełniające wyrażenie warunkowe.",
      "W relacji wynikowej występują wyłącznie te krotki, które spełniają warunek złączenia."
    ],
    "correct": [0, 1],
    "explanation": "Złączenie naturalne polega na połączeniu w pary tych krotek z relacji R i S, które mają identyczne wartości dla wszystkich wspólnych atrybutów i jest oznaczane RS. W rezultacie powstaje relacja, której schemat zawiera atrybuty relacji R i relacji S, przy czym wspólna część uwzględniana jest tylko raz."
  },
  {
    "question": "W relacji jeden-do-wielu, które stwierdzenia są prawdziwe?",
    "answers": [
      "Rekord w tabeli A może mieć wiele dopasowanych do niego rekordów z tabeli B.",
      "Rekord w tabeli B ma tylko jeden dopasowany rekord w tabeli A.",
      "Jest to najrzadziej spotykany typ relacji.",
      "Każdy rekord w tabeli A może mieć tylko jeden dopasowany rekord z tabeli B."
    ],
    "correct": [0, 1],
    "explanation": "W relacji jeden-do-wielu rekord w tabeli A może mieć wiele dopasowanych do niego rekordów z tabeli B, ale rekord w tabeli B ma tylko jeden dopasowany rekord w tabeli A[cite: 80]."
  },
  {
    "question": "Które typy danych numerycznych w MySQL zajmują 4 bajty pamięci?",
    "answers": [
      "TINYINT",
      "INT",
      "FLOAT",
      "BIGINT"
    ],
    "correct": [1, 2],
    "explanation": "Typy danych INT i FLOAT zajmują 4 bajty pamięci. TINYINT zajmuje 1 bajt, a BIGINT 8 bajtów."
  },
  {
    "question": "Które z poniższych są typami danych tekstowych w MySQL?",
    "answers": [
      "DATE",
      "VARCHAR",
      "TEXT",
      "BOOLEAN"
    ],
    "correct": [1, 2],
    "explanation": "VARCHAR i TEXT są typami danych tekstowych. DATE jest typem danych związanych z datą, a BOOLEAN jest typem danych numerycznych."
  },
  {
    "question": "Które z poniższych są problemami wynikającymi z przechowywania wszystkich danych w jednej, nieznormalizowanej tabeli?",
    "answers": [
      "Nadmierne zużycie zasobów przez przechowywanie tych samych informacji wiele razy.",
      "Problemy z aktualizacją danych, np. konieczność modyfikacji wielu wystąpień tej samej informacji.",
      "Brak możliwości wykonania podstawowych operacji na danych, gdy kolumny zawierają kolekcje wartości.",
      "Problem z dodawaniem nowych rekordów bez znajomości wszystkich powiązanych informacji."
    ],
    "correct": [0, 1, 2, 3],
    "explanation": "Nieznormalizowana tabela generuje problemy takie jak: te same informacje przechowywane wiele razy (zajmując niepotrzebnie zasoby), problemy z aktualizacją (konieczność modyfikacji wszystkich wystąpień), kolumny zawierające kolekcje wartości (brak możliwości wykonania podstawowych operacji i nieefektywne przeszukiwanie), usunięcie rekordu (skutkuje utratą informacji, której nie chcielibyśmy tracić) oraz problem z dodawaniem studenta (konieczne określenie informacji, których być może jeszcze nie znamy)."
  },
  {
    "question": "Czym jest 'normalizacja' bazy danych?",
    "answers": [
      "Procesem optymalizacji zapytań SQL.",
      "Procesem organizacji danych w bazie danych, polegającym na tworzeniu tabel i ustanawianiu powiązań w celu eliminacji powtarzających się i niespójnych zależności.",
      "Metodą zabezpieczania danych przed nieautoryzowanym dostępem.",
      "Procesem usuwania redundancji (nadmiarowości) danych w bazie."
    ],
    "correct": [1, 3],
    "explanation": "Normalizacja to proces organizacji danych w bazie danych. Polega on na tworzeniu tabel i ustanawianiu pomiędzy nimi powiązań według reguł obowiązujących zarówno przy ochronie danych, jak i uelastycznianiu bazy danych przez eliminowanie powtarzających się i niespójnych zależności. Normalizując bazę danych usuwamy z niej nadmiarowość tzw. redundancje."
  },
  {
    "question": "Co jest głównym wymogiem dla relacji, aby znajdowała się w Pierwszej Postaci Normalnej (1PN)?",
    "answers": [
      "Każdy atrybut niekluczowy musi być w pełni funkcyjnie zależny od klucza głównego.",
      "Żaden atrybut (kolumna) w tabeli nie może być podzielny dalej (wartości atrybutów są atomowe).",
      "Nie może być powtarzających się grup.",
      "Żadna informacja w kolumnie, która nie jest kluczem podstawowym, nie może zależeć od niczego innego, jak tylko od klucza podstawowego."
    ],
    "correct": [1, 2],
    "explanation": "Pierwsza postać normalna wymaga, aby żaden atrybut (kolumna) w tabeli nie był podzielny dalej (wartości atrybutów są atomowe), a także, aby nie było powtarzających się grup. Definicja mówi również, że 'Relacja jest w pierwszej postaci normalnej wtedy i tylko wtedy gdy każdy atrybut niekluczowy jest funkcyjnie zależny od klucza głównego'."
  },
  {
    "question": "Co jest celem normalizacji do Drugiej Postaci Normalnej (2PN)?",
    "answers": [
      "Eliminowanie powtarzających się grup atrybutów.",
      "Wykluczenie zależności funkcyjnych od części klucza złożonego.",
      "Rozdzielenie danych tak, aby każda informacja w wierszu nie zależała tylko od części klucza głównego.",
      "Eliminowanie zależności przechodnich między danymi."
    ],
    "correct": [1, 2],
    "explanation": "Druga postać normalna dotyczy zależności funkcyjnych od części klucza złożonego, normalizacja do drugiej postaci ma na celu wykluczenie takich zależności. Druga postać normalna mówi, że żadna informacja w wierszu nie może zależeć tylko od części klucza głównego (podstawowego)."
  },
  {
    "question": "Jaki problem rozwiązuje Trzecia Postać Normalna (3PN)?",
    "answers": [
      "Problemy związane z nieatomowymi atrybutami.",
      "Zależności funkcyjne od części klucza złożonego.",
      "Zależności przechodnie pomiędzy danymi.",
      "Sytuacje, gdzie informacja w kolumnie (niebędącej kluczem podstawowym) zależy od czegoś innego niż tylko od klucza podstawowego."
    ],
    "correct": [2, 3],
    "explanation": "Trzecia postać normalna ma na celu wykluczenie zależności przechodnich pomiędzy danymi. Mówi, że żadna informacja w kolumnie, która nie jest kluczem podstawowym, nie może zależeć od niczego innego, jak tylko od klucza podstawowego."
  },
  {
    "question": "Które z poniższych stwierdzeń są prawdziwe odnośnie Postaci Normalnej Boyce'a-Codda (BCPN)?",
    "answers": [
      "Jest to właściwie suma pierwszej, drugiej i trzeciej postaci normalnej.",
      "Każdy atrybut relacji musi zależeć funkcjonalnie tylko od jej klucza głównego.",
      "Jest to najbardziej złożona postać normalna, rzadko stosowana w praktyce.",
      "Posługując się tą definicją można stwierdzić, czy relacja spełnia warunki relacyjnego modelu danych."
    ],
    "correct": [0, 1, 3],
    "explanation": "Definicja postaci normalnej Boyce'a-Codda stanowi właściwie sumę pierwszej, drugiej i trzeciej postaci normalnej. Relacja jest w postaci normalnej Boyce'a-Codda wtedy i tylko wtedy, kiedy każdy jej atrybut zależy funkcjonalnie tylko od jej klucza głównego. Posługując się wyłącznie ta definicja można stwierdzić, czy relacja spełnia warunki relacyjnego modelu danych."
  },
  {
    "question": "Dlaczego często normalizacja baz danych zatrzymuje się na 3PN lub BCPN, a dalsza normalizacja jest nieopłacalna?",
    "answers": [
      "Dalsza normalizacja powoduje zbyt duży wzrost objętości bazy danych.",
      "Dalsza normalizacja zazwyczaj prowadzi do dużego spadku wydajności, głównie czasu realizacji zapytań.",
      "Zwiększa się ilość prostych zapytań do bazy danych w ramach uzyskania danych z wielu tabel, co znacznie wpływa na obniżenie prędkości wykonania zapytań.",
      "Wyższe postaci normalne są zbyt trudne do zrozumienia dla większości projektantów baz danych."
    ],
    "correct": [1, 2],
    "explanation": "Dalsza normalizacja zazwyczaj nie jest nieopłacalna ze względu na duży spadek wydajności tak znormalizowanych baz danych (głównie chodzi o czas realizacji zapytań w przypadku dużych zbiorów danych). Znormalizowanie bazy do postaci 5PN powoduje, że zwiększa się ilość prostych zapytań do bazy danych w ramach uzyskania danych z wielu tabel, co znacznie wpływa no obniżenie prędkości wykonania zapytań."
  },
  {
    "question": "Czwarta Postać Normalna (4PN) służy do:",
    "answers": [
      "Eliminacji zależności przechodnich.",
      "Eliminacji relacji typu (jeden-do-wielu) zachodzących między niezależnymi kolumnami.",
      "Zapewnienia atomowości atrybutów.",
      "Podziału tabeli na maksymalną ilość tabel w celu uniknięcia redundancji."
    ],
    "correct": [1],
    "explanation": "Czwarta postać normalna służy do eliminacji relacji miedzy tabelami typu (jeden - do - wielu) zachodzących miedzy niezależnymi kolumnami."
  },
  {
    "question": "Piąta Postać Normalna (5PN) polega na:",
    "answers": [
      "Zapewnieniu, że żaden atrybut niekluczowy nie zależy od części klucza złożonego.",
      "Podziale tabeli źródłowej na maksymalną ilość tabel w celu uniknięcia redundancji.",
      "Eliminacji wszystkich zależności funkcyjnych.",
      "Zwiększaniu wydajności bazy danych poprzez redukcję liczby tabel."
    ],
    "correct": [1],
    "explanation": "Piata postać normalna polega na podziale tabeli źródłowej na maksymalna ilość tabel w celu uniknięcia redundancji (nadmiarowości)."
  },
   {
    "question": "Czym jest SQL (Structured Query Language)?",
    "answers": [
      "Językiem programowania aplikacji internetowych.",
      "Międzynarodowym standardem umożliwiającym dostęp i przetwarzanie danych w relacyjnej bazie danych.",
      "Systemem operacyjnym dla baz danych.",
      "Językiem do tworzenia grafiki 3D."
    ],
    "correct": [1],
    "explanation": "SQL (ang. Structured Query Language – Strukturalny Język Zapytań) to język umożliwiający dostęp i przetwarzanie danych w relacyjnej bazie danych. Jest międzynarodowym standardem, do którego stosują się wszyscy producenci relacyjnych baz danych."
  },
  {
    "question": "Które z poniższych są dialektami języka SQL wymienionymi w prezentacji?",
    "answers": [
      "Java.",
      "Transact-SQL (T-SQL).",
      "PL/SQL.",
      "SQL/PSM."
    ],
    "correct": [1, 2, 3],
    "explanation": "Pomimo prób standaryzacji powstało wiele dialektów, m.in: Transact-SQL (T-SQL), PL/SQL (firmy ORACLE) oraz SQL/PSM (najpopularniejszy silnik relacyjny w serwisach WWW – MySQL)."
  },
  {
    "question": "Do jakich głównych podzbiorów zalicza się zapytania SQL?",
    "answers": [
      "SQL DDL (Data Definition Language).",
      "SQL DML (Data Manipulation Language).",
      "SQL DCL (Data Control Language).",
      "SQL DQL (Data Query Language).",
      "SQL TCL (Transaction Control Language)."
    ],
    "correct": [0, 1, 2, 3, 4],
    "explanation": "Zapytania SQL można zaliczyć do pięciu głównych podzbiorów: SQL DDL (Data Definition Language), SQL DML (Data Manipulation Language), SQL DCL (Data Control Language), SQL DQL (Data Query Language) oraz SQL TCL (Transaction Control Language)."
  },
  {
    "question": "Które polecenia należą do kategorii SQL DDL (Data Definition Language)?",
    "answers": [
      "INSERT.",
      "CREATE.",
      "DROP.",
      "ALTER."
    ],
    "correct": [1, 2, 3],
    "explanation": "DDL (Data Definition Language) umożliwia operowanie na strukturach, w których dane są przechowywane. Najważniejsze polecenia tej grupy to: CREATE (np. CREATE TABLE, CREATE DATABASE), DROP (np. DROP TABLE, DROP DATABASE) oraz ALTER (np. ALTER TABLE ADD COLUMN)."
  },
  {
    "question": "Do czego służy polecenie `ALTER TABLE`?",
    "answers": [
      "Do dodawania nowych rekordów do tabeli.",
      "Do usuwania kolumn z tabeli.",
      "Do zmiany typu danych w kolumnie tabeli.",
      "Do zmiany nazwy tabeli."
    ],
    "correct": [1, 2, 3],
    "explanation": "`ALTER` służy do zmiany struktury. Przykłady użycia to: `ALTER TABLE miasta DROP COLUMN Powierzchnia;` (usuwa kolumnę), `ALTER TABLE miasta CHANGE name varchar(40);` (zmienia typ pola) oraz `ALTER TABLE miasta RENAME TO City;` (zmienia nazwę tabeli)."
  },
  {
    "question": "Które polecenia należą do kategorii SQL DML (Data Manipulation Language)?",
    "answers": [
      "GRANT.",
      "INSERT.",
      "UPDATE.",
      "DELETE."
    ],
    "correct": [1, 2, 3],
    "explanation": "DML (Data Manipulation Language) służy do wykonywania operacji na danych. Najważniejsze polecenia z tego zbioru to: INSERT (umieszczenie danych), UPDATE (zmiana danych) oraz DELETE (usunięcie danych)."
  },
  {
    "question": "Jaka jest funkcja klauzuli `WHERE` w zapytaniu `SELECT`?",
    "answers": [
      "Określa, które kolumny mają być wyświetlone.",
      "Służy do określenia relacji/tabeli, których dotyczy zapytanie.",
      "Formułuje warunek, który muszą spełniać rekordy, aby zostały wybrane.",
      "Sortuje wyniki zapytania."
    ],
    "correct": [2],
    "explanation": "W klauzuli `WHERE` formułuje się warunek. Określa on ograniczenia, jakie mają spełniać pola rekordów, aby zostać wybrane w danym zapytaniu."
  },
  {
    "question": "Które z poniższych poleceń należą do SQL DCL (Data Control Language)?",
    "answers": [
      "SELECT.",
      "GRANT.",
      "REVOKE.",
      "COMMIT."
    ],
    "correct": [1, 2],
    "explanation": "DCL (Data Control Language) ma zastosowanie do nadawania uprawnień do obiektów bazodanowych. Najważniejsze polecenia w tej grupie to: GRANT (nadawanie uprawnień) oraz REVOKE (odbieranie uprawnień)."
  },
  {
    "question": "Do czego służy klauzula `ORDER BY`?",
    "answers": [
      "Do filtrowania danych.",
      "Do grupowania danych.",
      "Do sortowania wyników zapytania.",
      "Posiada specyfikatory ASC (rosnąco) i DESC (malejąco)."
    ],
    "correct": [2, 3],
    "explanation": "Do sortowania wyników służy klauzula ORDER BY występująca na końcu zapytania SELECT. Posiada ona dwa specyfikatory ASC (rosnąco - domyślny) i DESC (malejąco)."
  },
  {
    "question": "Które z poniższych poleceń są elementami SQL TCL (Transaction Control Language)?",
    "answers": [
      "CREATE TABLE.",
      "BEGIN Transaction.",
      "COMMIT Transaction.",
      "ROLLBACK Transaction."
    ],
    "correct": [1, 2, 3],
    "explanation": "TCL (Transaction Control Language) to polecenia pozwalające na obsługę transakcji w SQL: BEGIN Transaction (otwarcie transakcji), COMMIT Transaction (potwierdzenie transakcji) oraz ROLLBACK Transaction (wycofanie transakcji w przypadku wystąpienia błędu)."
  },
  {
    "question": "Które z poniższych zasad konstrukcji wyrażeń SQL są prawdziwe?",
    "answers": [
      "Nazwy umożliwiają dostęp do obiektów z różnych poziomów za pomocą kropki jako separatora.",
      "Możliwe jest konstruowanie operacji porównania na wierszach, np. (A1,B1,C1)<(A2,B2,C2).",
      "Każda instrukcja kończy się średnikiem.",
      "Stałe tekstowe zapisywane są w nawiasach kwadratowych."
    ],
    "correct": [0, 1, 2],
    "explanation": "Zgodnie z prezentacją, nazwy umożliwiają dostęp do obiektów z różnych poziomów za pomocą wyrażeń ścieżkowych (np. baza_danych.tabela.pole - separatorem poziomów jest kropka)[cite: 313, 314]. [cite_start]Możliwe jest konstruowanie operacji porównania na wierszach[cite: 315]. [cite_start]Każda instrukcja zaczyna się słowem kluczowym, może zawierać modyfikatory i kończy się średnikiem[cite: 316]. Stałe tekstowe zapisywane są w cudzysłowach, np. [cite_start]'Warszawa'[cite: 318]."
  },
  {
    "question": "Jaki jest cel klauzuli `WHERE` w zapytaniu SQL?",
    "answers": [
      "Określenie, które kolumny mają być wyświetlone.",
      "Formułowanie warunku, który muszą spełniać pola rekordów, aby zostać wybrane w danym zapytaniu.",
      "Sortowanie wyników tabeli wynikowej.",
      "Określenie tabel, których dotyczy zapytanie."
    ],
    "correct": [1],
    "explanation": "W klauzuli WHERE formułuje się warunek. [cite_start]Określa on ograniczenia, jakie mają spełniać pola rekordów, aby zostać wybrane w danym zapytaniu[cite: 345]."
  },
  {
    "question": "Które z poniższych operatorów relacyjnych są używane w SQL do porównywania wartości?",
    "answers": [
      "=",
      "<> (lub !=)",
      ">=",
      "AND"
    ],
    "correct": [0, 1, 2],
    "explanation": "Operatory relacyjne to =, <, >, <=, >=, != (<>) służą do porównywania liczb, dat, napisów[cite: 349, 350]. [cite_start]AND jest operatorem logicznym[cite: 352]."
  },
  {
    "question": "Które z poniższych funkcji tekstowych są dostępne w SQL i do czego służą?",
    "answers": [
      "CONCAT(łańcuch1, łańcuch2, ...) – zwraca rezultat w postaci połączonych argumentów.",
      "LENGTH(łańcuch) – zwraca długość łańcucha w bajtach.",
      "LOCATE(podłańcuch, łańcuch, położenie) – zwraca położenie pierwszego wystąpienie ciągu znaków podłańcuch w łańcuchu.",
      "TRIM(łańcuch) – usuwa spacje z początku i końca łańcucha."
    ],
    "correct": [0, 1, 2, 3],
    "explanation": "Prezentacja opisuje wszystkie wymienione funkcje tekstowe: CONCAT (łączy argumenty) [cite: 371][cite_start], LENGTH (zwraca długość łańcucha w bajtach) [cite: 392][cite_start], LOCATE (zwraca położenie podłańcucha) [cite: 402][cite_start], oraz TRIM (usuwa spacje)[cite: 422]."
  },
  {
    "question": "Które z poniższych funkcji obliczających są wymienione w prezentacji?",
    "answers": [
      "AVG(x) – zwraca wartość średnią ze zbioru liczb.",
      "COUNT(x) – zlicza wartości różne od NULL danego zbioru.",
      "MEDIAN(x) – zwraca wartość mediany (wartość środkową) danego zbioru liczb.",
      "SUM(x) – zwraca wartość sumy liczb zbioru."
    ],
    "correct": [0, 1, 2, 3],
    "explanation": "Prezentacja wymienia funkcje obliczające: AVG(x), COUNT(x), MEDIAN(x) (dostępna jedynie w bazie Oracle) oraz SUM(x)[cite: 446]."
  },
  {
    "question": "Jaka jest różnica między klauzulami `WHERE` i `HAVING` w operacjach grupowania?",
    "answers": [
      "`WHERE` działa po sformowaniu grup, a `HAVING` przed.",
      "`WHERE` działa przed sformowaniem grup, a `HAVING` po.",
      "`HAVING` musi odnosić się do kryteriów wykorzystanych przy tworzeniu grup.",
      "`WHERE` jest używane do filtrowania pojedynczych rekordów, a `HAVING` do filtrowania grup."
    ],
    "correct": [1, 2, 3],
    "explanation": "`WHERE` działa przed sformowaniem grup [cite: 453][cite_start], a `HAVING` po[cite: 454]. [cite_start]Predykat opcji `HAVING` musi więc odnosić się do kryteriów wykorzystanych przy tworzeniu grup[cite: 454]. `WHERE` filtruje wiersze, zanim zostaną pogrupowane, podczas gdy `HAVING` filtruje grupy po ich utworzeniu."
  },
  {
    "question": "Czym charakteryzuje się iloczyn kartezjański w SQL?",
    "answers": [
      "Zwraca tylko te rekordy, które spełniają warunek złączenia.",
      "Zwraca wszystkie kombinacje krotek z łączonych relacji.",
      "Jest wykonywany, gdy w zapytaniu podano więcej niż jedną tabelę bez jawnego warunku złączenia.",
      "Bierze pod uwagę rekordy mające tę samą nazwę w obu relacjach."
    ],
    "correct": [1, 2],
    "explanation": "W przypadku podania więcej niż jednej tabeli (bez jawnego warunku złączenia), wykonywana jest operacja iloczynu kartezjańskiego[cite: 323]. [cite_start]Iloczyn kartezjański zwraca wszystkie kombinacje krotek z łączonych relacji[cite: 475]."
  },
  {
    "question": "Które z poniższych są prawdziwe odnośnie zagnieżdżania zapytań w SQL?",
    "answers": [
      "Zapytania mogą operować na wynikach innych zapytań.",
      "Operatory IN oraz ANY pozwalają na przeszukanie pewnego zbioru.",
      "Różnica między IN a ANY polega na możliwości zastosowania różnych operatorów relacyjnych (zamiast '=') dla ANY.",
      "Zagnieżdżanie zapytań zawsze spowalnia działanie bazy danych."
    ],
    "correct": [0, 1, 2],
    "explanation": "Zapytania w SQL mogą operować na wynikach innych zapytań, możliwe jest więc tzw. zagnieżdżanie zapytań[cite: 462]. [cite_start]Operatory IN oraz ANY pozwalają na przeszukanie pewnego zbioru[cite: 470]. [cite_start]Różnica pomiędzy nimi polega na możliwości zastosowania różnych operatorów relacyjnych (zamiast '=') dla ANY[cite: 470]."
  },
  {
    "question": "Jakie są cechy połączenia wewnętrznego (INNER JOIN)?",
    "answers": [
      "W tabeli wynikowej występują wyłącznie te krotki, które spełniają warunek złączenia.",
      "Zwraca wszystkie rekordy z wybranej relacji, nawet jeśli nie ma dopasowania w drugiej.",
      "Tabela wynikowa składa się ze wszystkich kolumn tabel wejściowych.",
      "Jest to najbardziej powszechny typ połączenia."
    ],
    "correct": [0, 2],
    "explanation": "W wyniku złączenia wewnętrznego (INNER JOIN) otrzymujemy tabelę wynikową, składającą się ze wszystkich kolumn tabel wejściowych[cite: 484]. [cite_start]Tabela wynikowa zawierać będzie tylko takie elementy, dla których warunki złączenia wewnętrznego będą spełnione[cite: 485]."
  },
  {
    "question": "W przypadku połączeń zewnętrznych (OUTER JOIN), które z poniższych stwierdzeń są prawdziwe?",
    "answers": [
      "LEFT OUTER JOIN zwraca wszystkie wystąpienia relacji po lewej stronie połączenia.",
      "RIGHT OUTER JOIN zwraca wszystkie wystąpienia relacji po prawej stronie połączenia.",
      "FULL OUTER JOIN zwraca wszystkie wystąpienia obu relacji.",
      "Połączenia zewnętrzne zawsze zwracają tylko dopasowane rekordy."
    ],
    "correct": [0, 1, 2],
    "explanation": "Połączenia zewnętrzne zwracają wszystkie rekordy z wybranej relacji[cite: 504]. [cite_start]LEFT zwraca wszystkie wystąpienia relacji po lewej stronie połączenia [cite: 505][cite_start], RIGHT zwraca wszystkie wystąpienia relacji po prawej stronie połączenia [cite: 505][cite_start], a FULL zwraca wszystkie wystąpienia obu relacji[cite: 506]."
  },
  {
    "question": "Które z poniższych stwierdzeń opisują wyzwania związane z realizacją programów transformujących bazę danych?",
    "answers": [
      "Awaryjność środowiska sprzętowo-programowego.",
      "Współbieżny dostęp do danych.",
      "Rozproszenie baz danych.",
      "Zbyt mała ilość danych do przetworzenia."
    ],
    "correct": [0, 1, 2],
    "explanation": "Niebezpieczeństwa związane z realizacją programu transformującego bazę danych obejmują: Awaryjność środowiska sprzętowo-programowego, Współbieżny dostęp do danych oraz Rozproszenie baz danych[cite: 1000, 1001, 1002]."
  },
  {
    "question": "Czym jest 'transakcja' w kontekście baz danych?",
    "answers": [
      "Pojedyncza operacja odczytu danych.",
      "Sekwencja logicznie powiązanych operacji na bazie danych, która przeprowadza bazę danych z jednego stanu spójnego w inny stan spójny.",
      "Program do tworzenia kopii zapasowych bazy danych.",
      "Operacja, która zawsze narusza ograniczenia integralnościowe."
    ],
    "correct": [1],
    "explanation": "Transakcja jest sekwencją logicznie powiązanych operacji na bazie danych, która przeprowadza bazę danych z jednego stanu spójnego w inny stan spójny[cite: 1020]."
  },
  {
    "question": "Które z poniższych poleceń SQL są związane z zarządzaniem transakcjami?",
    "answers": [
      "SELECT.",
      "COMMIT.",
      "ROLLBACK.",
      "SAVEPOINT."
    ],
    "correct": [1, 2, 3],
    "explanation": "W systemach baz danych realizujących standard SQL polecenia dotyczące transakcji to: BEGIN, BEGIN WORK, START TRANSACTION – rozpoczęcie transakcji; COMMIT – zatwierdzenie zmian; ROLLBACK – odrzucenie zmian; SAVEPOINT nazwa – zdefiniowanie punktu pośredniego; RELEASE SAVEPOINT nazwa – skasowanie punktu pośredniego; [cite_start]ROLLBACK TO SAVEPOINT nazwa – wycofanie transakcji do stanu zapamiętanego w podanym punkcie pośrednim[cite: 1034, 1035, 1036, 1037, 1038, 1039]."
  },
  {
    "question": "Jakie są podstawowe własności transakcji, znane jako zasada ACID?",
    "answers": [
      "Atomowość (Atomicity).",
      "Spójność (Consistency).",
      "Szybkość (Speed).",
      "Izolacja (Isolation).",
      "Trwałość (Durability)."
    ],
    "correct": [0, 1, 3, 4],
    "explanation": "Własności transakcji to Atomowość (Atomicity), Spójność (Consistency), Izolacja (Isolation) i Trwałość (Durability)[cite: 1041, 1046, 1050, 1055]."
  },
  {
    "question": "Co oznacza własność 'Atomowość' (Atomicity) transakcji?",
    "answers": [
      "Transakcje są od siebie logicznie odseparowane.",
      "Wyniki zatwierdzonych transakcji nie mogą zostać utracone.",
      "Zbiór operacji wchodzących w skład transakcji jest niepodzielny: albo zostaną wykonane wszystkie operacje transakcji albo żadna.",
      "Transakcja przeprowadza bazę danych z jednego stanu spójnego do innego stanu spójnego."
    ],
    "correct": [2],
    "explanation": "Atomowość (A) oznacza, że zbiór operacji wchodzących w skład transakcji jest niepodzielny: albo zostaną wykonane wszystkie operacje transakcji albo żadna (niepodzielność)[cite: 1043]."
  },
  {
    "question": "Które z poniższych typów nieprawidłowych odczytów (anomalii) są związane z poziomami izolacji transakcji?",
    "answers": [
      "Brudny odczyt (Dirty read).",
      "Odczyt bez powtórzeń (Non-repeatable read).",
      "Odczyt widmo (Phantom).",
      "Szybki odczyt (Fast read)."
    ],
    "correct": [0, 1, 2],
    "explanation": "W celu zdefiniowania poziomów izolacji transakcji określono 3 rodzaje nieprawidłowych odczytów: Brudny odczyt (Dirty read), Odczyt bez powtórzeń (Non-repeatable read) oraz Odczyt widmo (Phantom)[cite: 1095, 1096, 1107, 1109]."
  },
  {
    "question": "Który poziom izolacji transakcji jest domyślny w PostgreSQL i co oznacza?",
    "answers": [
      "SERIALIZABLE, co oznacza, że transakcja widzi stan bazy danych tak, jak gdyby była wykonywana w sposób sekwencyjny.",
      "READ COMMITED, co oznacza, że transakcja odczytuje tylko obiekty, których zmiany zostały zatwierdzone.",
      "READ UNCOMMITED, co oznacza, że transakcja odczytuje obiekty w dowolnej chwili, nawet te niezakończone.",
      "REPEATABLE READS, co oznacza, że żadna wartość odczytana lub zmieniona przez T nie może być zmieniona przez inną transakcję dopóki T nie skończy się."
    ],
    "correct": [1],
    "explanation": "PostgreSQL domyślnie pracuje w trybie automatycznego zatwierdzania transakcji. [cite_start]Domyślnym poziomem izolacji w PostgreSQL jest READ COMMITED, co oznacza, że transakcja odczytuje tylko obiekty, których zmiany zostały zatwierdzone[cite: 1086, 1127, 1128]."
  },
  {
    "question": "Jakie są metody radzenia sobie z zakleszczeniami w bazach danych?",
    "answers": [
      "Zapobieganie.",
      "Wykrywanie.",
      "Ustalenie limitu oczekiwania na blokadę (timeout).",
      "Zwiększanie liczby transakcji w cyklu."
    ],
    "correct": [0, 1, 2],
    "explanation": "Są trzy sposoby radzenia sobie z zakleszczeniami: zapobieganie, wykrywanie oraz ustalenie limitu oczekiwania na blokadę (timeout)[cite: 1191, 1192, 1193, 1194, 1195]."
  },
  {
    "question": "W protokole ścisłego blokowania dwufazowego (Strict 2PL), co dzieje się z blokadami trzymanymi przez transakcję?",
    "answers": [
      "Są zwalniane stopniowo w trakcie działania transakcji.",
      "Są zwalniane jednocześnie, w chwili gdy transakcja kończy się (wycofaniem lub zatwierdzeniem).",
      "Są utrzymywane w nieskończoność.",
      "Są zwalniane tylko w przypadku awarii systemu."
    ],
    "correct": [1],
    "explanation": "Wszystkie blokady trzymane przez transakcję są zwalniane jednocześnie, w chwili gdy transakcja kończy się (wycofaniem lub zatwierdzeniem)[cite: 1164]."
  },
  {
    "question": "Co jest warunkiem poprawnego wykonania transakcji rozproszonej?",
    "answers": [
      "Musi być realizowana tylko na jednym serwerze.",
      "Musi być zatwierdzona na wszystkich serwerach, na których ulokowane są modyfikowane dane.",
      "Nie może obejmować modyfikacji danych.",
      "Wymaga ręcznego zarządzania blokadami przez użytkownika."
    ],
    "correct": [1],
    "explanation": "Warunkiem poprawnego wykonania transakcji rozproszonej jest jej zatwierdzenie na wszystkich serwerach[cite: 1222]."
  }

],





  "angielski": [
    {
    "question":"Translate: get carried away",
    "answers":["dać się ponieśc emocjom","działać komuś na nerwy","mieć wrażenie","zwrócić czyjąś uwagę"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: get in touch",
    "answers":["zwrócić czyjąś uwagę","dotknąć kogoś","skontaktować się","spotkać się z kimś"],
    "correct":2,
    "explanation":""
    },
    {
    "question":"Translate: get it (understand)",
    "answers":["Dać do zrozumienia","zrozumieć (coś)","porozumienie","wpaść na jakiś pomysł"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: get on someone's nerves",
    "answers":["działać komuś na nerwy","być zdenerowoanym","wchodzić komus na glowę","ogólnie zdenerwowanie"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: get someone's attention",
    "answers":["lubić kogoś","zwrócić czyjąś uwagę","poświęcić komuś uwagę","ostrzec kogoś"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: get some rest",
    "answers":["iść spać","wynająć pokój","rozbić namiot","odpocząć"],
    "correct":3,
    "explanation":""
    },
    {
    "question":"Translate: get straight to the point",
    "answers":["prosto przed siebie","dążyć do celu","przejść do sedna","dotrzeć do jakiegoś punktu"],
    "correct":2,
    "explanation":""
    },
    {
    "question":"Translate: get the feeling",
    "answers":["czuć się jakoś","mieć wrażenie","mieć przeczucie","zastanawiać się"],
    "correct":[1, 2],
    "explanation":""
    },
    {
    "question":"Translate: get to do something",
    "answers":["mieć okazję / możliwość coś zrobić","mieć coś do zrobienia","mieć obowiązek do wykonania","zrobić coś"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: get together",
    "answers":["zebrać się (np. w grupę ludzi)", "poznać się","spotkać się","zabawić się"],
    "correct":[0, 2],
    "explanation":""
    },
    {
    "question":"Translate: Zająć sie problemem",
    "answers":["Warn about the dangers","tackle the problem","take action","do more to"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: zwiększyć finansowanie",
    "answers":["offer alternatives","increase funding","take actions","do more to"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: przeprowadzić badania",
    "answers":["crack down on","enforce a law","carry out research","research something"],
    "correct":2,
    "explanation":""
    },
    {
    "question":"Translate: zakazać stosowania czegoś",
    "answers":["ban the use of","crack down on","offer alternatives","get carried away"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: take action",
    "answers":["podjąć wyzwanie","podjąć działanie","zrobić coś z czymś","zrobić więcej aby..."],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: do more to",
    "answers":["stworzyć więcej czegoś","zrobić więcej aby","poprawić coś","żadne z powyższych"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: ostrzegać przed niebezpieczeństwem",
    "answers":["warn about dangers","crack on dawn","ban the use of","tackle the problem"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: crack down on",
    "answers":["zniszczyć coś","rozprawić się z czymś","oferować alternatywy","ostro się za coś zabrać"],
    "correct":[1, 3],
    "explanation":""
    },
    {
    "question":"Translate: offer alternatives",
    "answers":["zaoferować zupełnie co innego","oferowac alternatywy","zaoferowac pomoc","żadne z powyższych"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: egzekwować prawo",
    "answers":["enforce a law","be a lawyer","breaking the law","respect the law"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: slow delivery",
    "answers":["opóźniona dostawa","opóźniony pociąg","trudności w komunikacji","żadne z powyższych"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: faulty product",
    "answers":["produkt z promocji","wadliwy produkt","produkt z przeceny","wyjątkowy produkt"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: broken promises",
    "answers":["złamane obietnice","złamane serce","załamanie","żadne z powyższych"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: poor customer service",
    "answers":["dobra obsługa klienta","słaba obsluga klienta","obsługa klienta"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: lack of communication",
    "answers":["szczęśliwa komunikacja","brak porozumienia","brak komunikacji","dobra komunikacja"],
    "correct":[1, 2],
    "explanation":""
    },
    {
    "question":"Translate: rude staff",
    "answers":["nieuprzejmy personel","nieładne rzeczy","nieuprzejmy klient","żadne z powyższych"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: aggressive salespeople",
    "answers":["agresywni klienci","agresywni sprzedawcy","agresywni ludzie","agresywne korporacje"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: billing disputes",
    "answers":["wysokie rachunki","podatki","spory dotyczące racunków / faktur","żadne z powyższych"],
    "correct":2,
    "explanation":""
    },
    {
    "question":"Translate: cold callers",
    "answers":["akwizytorzy telefoniczni","telefoniczna obsługa reklamacji","ozmowy telefoniczne","żadne z powyższych"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: false advertising",
    "answers":["reklama o promocjach","reklama wprowadzająca w błąd","fałszywa reklama","reklama na bilboardzie"],
    "correct":[1, 2],
    "explanation":""
    },
    {
    "question":"Translate: delighted",
    "answers":["uszczęśliwiony","zachwycony","zabawny","miły"],
    "correct":[0, 1],
    "explanation":""
    },
    {
    "question":"Translate: depressed",
    "answers":["przygnębiony","wściekły","zdołowany","zaniepokojony"],
    "correct":[0, 2],
    "explanation":""
    },
    {
    "question":"Translate: rozbawiony",
    "answers":["delighted","entertained","happy","infuriated"],
    "correct":1,
    "explanation":""
    },
    {
    "question":"Translate: wściekły, rozwścieczony",
    "answers":["infuriated","overwhelmed","depressed","scared"],
    "correct":0,
    "explanation":""
    },
    {
    "question":"Translate: przytłoczony",
    "answers":["scared","upset","overwhelmed","depressed"],
    "correct":2,
    "explanation":""
    },
    {
    "question":"Translate: scared",
    "answers":["zlękniony","przestraszony","smutny","wściekły"],
    "correct":[0,1],
    "explanation":""
    },
    {
    "question":"Translate: astonished",
    "answers":["przekonany","przestraszony","zaskoczony","wściekły"],
    "correct":2,
    "explanation":""
    },
    {
    "question":"Translate: convinced",
    "answers":["przekonany","smutny","niedowiarek","wściekły"],
    "correct":0,
    "explanation":""
    }
    
  ],

  "fiszki_bazy_danych":[

    {
      "term": "Baza danych",
      "definition": "zbiór informacji opisujący wybrany fragment rzeczywistości. Np. dla sklepu: dane dotyczące klientów, towarów, faktur, dla banku: dane klientów, ich rachunków, operacji na rachunkach"
    },
    {
      "term": "System zarządzania bazą danych (DBMS)",
      "definition": "zbiór narzędzi pozwalający na dostęp oraz na zarządzanie jedną lub wieloma bazami danych."
    },
    {
      "term": "System baz danych",
      "definition": "baza danych + DBMS."
    },
    {
      "term": "Schemat baz danych",
      "definition": "określa w jaka powinna być struktura danych oraz w jaki sposób dane są powiązane"
    },
    {
      "term": "Model danych",
      "definition": "zbiór ogólnych zasad posługiwania się danymi."
    },
    {
      "term": "DBMS - Procesor zapytań",
      "definition": "Przekształca zapytanie lub operację na bazie danych w ciąg poleceń żądających określonych danych."
    },
    {
      "term": "DBMS - Menedżer pamięci",
      "definition": "steruje umieszczaniem danych na dysku oraz przesyłaniem danych między dyskiem i pamięcią. Ze względu na wydajność DBMS zazwyczaj zarządza pamięcią."
    },
    {
      "term": "DBMS - Moduł zarządzania transakcjami",
      "definition": "Gwarantuje poprawność i kompletność wykonania wszystkich transakcji (jedno lub więcej zapytań stanowiące grupę zadań do wykonania w jednym ciągu)."
    },
    {
      "term": "Trwałość danych to",
      "definition": "Długi czas życia – kilka, kilkadziesiąt, kilkaset lat***Niezależność od działania aplikacji"
    },
    {
      "term": "Poprawne modelowanie świata rzeczywistego oznacza",
      "definition": "że struktura bazy danych musi odzwierciedlać we właściwy/poprawny sposób obiekty świata rzeczywistego i powiązania pomiędzy tymi obiektami."
    },
    {
      "term": "Autoryzacja dostępu do danych oznacza",
      "definition": "że dostęp do bazy danych mają tylko jej użytkownicy identyfikowani unikalną nazwą i hasłem. Ponadto, każdy użytkownik posiada określone uprawnienia w bazie danych."
    },
    {
      "term": "Współbieżność dostępu do danych to",
      "definition": "zagwarantowanie możliwości równoczesnej pracy wielu użytkownikom tej samej bazy danych. Co więcej, użytkownicy ci mogą jednocześnie pracować z tym samym zbiorem danych."
    },
    {
      "term": "Metadane to",
      "definition": "dane o bazie danych. Dane te opisują m.in.: dane przechowywane w bazie, struktury danych, użytkowników i ich uprawnienia, relacje między obiektami, dane o archiwizacji itp."
    },
    {
      "term": "Model danych czyli",
      "definition": "Obiekty ze świata rzeczywistego są reprezentowane w bazie danych za pomocą tzw. modelu danych."
    },
    {
      "term": "Wyróżnia się następujące modele danych:",
      "definition": "hierarchiczny *** sieciowy *** relacyjny *** obiektowy *** obiektowo-relacyjny *** semistrukturalny"
    },
    {
      "term": "Każdy model danych definiuje trzy podstawowe elementy:",
      "definition": "struktura danych *** zbiór predefiniowanych operacji na danych *** umożliwia nałożenie ograniczeń integralnościowych na reprezentowane w nim dane."
    },
    {
      "term": "Struktura danych",
      "definition": "służy do reprezentowania w bazie danych obiektów ze świata rzeczywistego. Przykładowo, grupa studentów może być reprezentowana w modelu obiektowym jako klasa, lub w modelu relacyjnym jako relacja. Poszczególni pracownicy są reprezentowani odpowiednio jako wystąpienia klasy (w modelu obiektowym) lub krotki relacji (w modelu relacyjnym)."
    },
    {
      "term": "w modelu relacyjnym operacje na danych oferowane przez model to:",
      "definition": "selekcja *** projekcja *** połączenie *** operacje na zbiorach."
    },
    {
      "term": "Użytkownicy SBD",
      "definition": "analitycy systemowi *** projektanci baz danych *** programiści aplikacji *** użytkownicy końcowi *** administratorzy systemów baz danych"
    },
    {
      "term": "SQL - Structured Query Language",
      "definition": "SQL jest językiem deklaratywnym. Oznacza to, że posługując się nim specyfikujemy tylko co chcemy otrzymać, nie specyfikujemy sposobu (algorytmu) w jaki ma być zrealizowane zadanie."
    },
    {
      "term": "Model związków encji zwany jest też",
      "definition": "modelem ER (ang. Entity – Relationship Model)."
    },
    {
      "term": "Diagram związków encji, zwany jest też",
      "definition": "diagramem ERD (ang. Entity – Relationship Diagram). ERD pozwala na graficzne zamodelowanie struktur danych oraz relacji pomiędzy nimi."
    },
    {
      "term": "Model danych w postaci diagramu związków encji zawiera trzy rodzaje elementów:",
      "definition": "encje *** atrybuty *** związki"
    },
    {
      "term": "Encja",
      "definition": "(obiekt) – jest rzeczą lub obiektem, rzeczywistym lub wyobrażonym, czymś co ma znaczenie dla nas i jest odróżnialne od innych rzeczy i obiektów, czymś o czym informacje powinny być znane i przechowywane."
    },
    {
      "term": "Własności encji",
      "definition": "Nazwa encji musi dokładnie reprezentować typ lub klasę rzeczy – a nie jakąkolwiek jej instancję (tj. wystąpienie). Np. nazwy kin „Bałtyk”, czy „Silver-Screen” nie mogą być użyte jako nazwy encji, gdyż encją jest KINO, zaś wymienione nazwy kin są tylko instancjami tej encji."
    },
    {
      "term": "Związki to",
      "definition": "zbiór istotnych powiązań pomiędzy zbiorami encjami. A zatem związek to uporządkowana lista encji, przy czym poszczególne encje mogą występować wielokrotnie. Inaczej mówiąc, każdy związek określa pewną relację między zbiorami egzemplarzy encji wchodzącymi w skład związku. W szczególnym przypadku może być powiązaniem tej samej encji ze sobą."
    },
    {
      "term": "Z(E1,…En) to",
      "definition": "instancja związku, gdzie E1,…En – encje występujące w związku Z."
    },
    {
      "term": "Atrybut – jest to",
      "definition": "własność encji danego typu, mająca znaczenie dla encji reprezentowana pewną wartością, np. liczbą rzeczywistą, obrazem, napisem, zapachem, itp. Inaczej mówiąc, atrybut – jest dowolnym szczegółem służącym do kwalifikowania, identyfikowania, klasyfikowania, określania ilości lub wyrażania stanu encji."
    },
    {
      "term": "Każdy związek ma:",
      "definition": "przypisaną nazwę, stopień, opcjonalność (opcjoalny czy wymagany)"
    },
    {
      "term": "Rodzaje atrybutów",
      "definition": "atrybut jednowartościowy, atrybut wuelowartościowy, atrybut pochodny"
    },
    {
      "term": "Atrybut jednowartościowy",
      "definition": "przyjmuje tylko jedną wartość dla każdego wystąpienia encji, np. dla każdego wystąpienia encji KINO atrybut kodkina ma pojedynczą wartość np. SC001 i z tego powodu atrybut kodkina jest jednowartościowy"
    },
    {
      "term": "Atrybut wielowartościowy",
      "definition": "może przyjmować wiele wartości dla pojedynczego wystąpienia encji, np. dla każdego z wystąpień encji KLIENT atrybut telefonklienta może zawierać wiele wartości (gdyż klient może posiadać więcej niż jeden telefon). Atrybut wielowartościowy może zawierać zbiór o ograniczonej z dołu i z góry liczbie elementów (np. atrybut telefonklienta może zawierać minimalnie jeden, a maksymalnie trzy numery telefonów."
    },
    {
      "term": "Atrybut pochodny",
      "definition": "to atrybut reprezentujący wartość, która jest wyliczana z podobnego atrybutu lub ze zbioru atrybutów, niekoniecznie pochodzącego z tego samego zbioru encji, np. czas realizacji zamówienia (liczba dni) , jaki upłynął od złożenia zamówienia przez klienta do momentu wysyłki zamówienia może być wyliczony jako różnica tych dat."
    },
    {
      "term": "Relacyjną bazą danych nazywamy",
      "definition": "bazę danych w postaci tabel połączonych relacjami."
    },
    {
      "term": "Tabela to",
      "definition": "(encja – relacja – klasa) w bazie danych nazywamy zbiór rekordów opisujących obiekty np. pracownicy zawierających informacje o tych obiektach w sposób ujednolicony."
    },
    {
      "term": "Pole to",
      "definition": "(atrybut – kolumna) - pojedyncza dana wchodząca w skład krotki np. nazwisko studenta, nr ewidencyjny pracownika, wielkość zapasu czy rodzaj filmu."
    },
    {
      "term": "Rekord to",
      "definition": "(krotka – obiekt (instancja klasy) – wiersz)– zestaw wartości atrybutów opisujących jeden obiekt identyfikowany przez wyróżnione atrybuty lub nazwę (pojedynczy wiersz w tabeli)"
    },
    {
      "term": "Związek to (w kontekscie relacyjnych baz danych)",
      "definition": "więź – asocjacja - związek pomiędzy dwoma encjami (klasami) pokazujący jakie rekordy (obiekty) z jednej encji odpowiadają rekordom z drugiej i jaki jest charakter tej odpowiedniości."
    },
    {
      "term": "Podstawową strukturą danych jest relacja ...",
      "definition": "będąca podzbiorem iloczynu kartezjańskiego dwóch wybranych zbiorów reprezentujących dopuszczalne wartości. Niech A1 = [a,b,c], A2 =[x,y], Wtedy A1 × A2 = {(a,x), (a,y), (b,x), (b,y), (c,x), (c,y)}"
    },
    {
      "term": "elementy relacji są nazywane",
      "definition": "krotkami (rekordami) analogicznie do iloczynu kartezjańskiego"
    },
    {
      "term": "Relacja",
      "definition": "skończony zbiór krotek (rekordów)"
    },
    {
      "term": "Klucz relacji",
      "definition": "to taki zbiór identyfikujący relacji, którego żaden podzbiór nie jest zbiorem identyfikującym relacji."
    },
    {
      "term": "Wyróżnia się klucze",
      "definition": "proste i złożone"
    },
    {
      "term": "Klucz jest kluczem prostym, jeśli",
      "definition": "zbiór identyfikujący relacji jest zbiorem jednoelementowym, w przeciwnym razie klucz jest kluczem złożonym"
    },
    {
      "term": "klucz podstawowy",
      "definition": "pole za pomocą którego byłby jednoznacznie identyfikowany w bazie."
    },
    {
      "term": "Postulaty Codd’a",
      "definition": "Jest to zestaw 13 zasad stworzonych przez Edgara F. Codd. Każda relacyjna baza danych musi je spełniać"
    },
    {
      "term": "Więź (relationship)(związki)",
      "definition": "to powiązanie pomiędzy parą tabel (relacji). — Istnieje ona wtedy, gdy dwie tabele są połączone przez klucz podstawowy i klucz obcy. Każda więź jest opisywana przez typ więzi istniejący między dwoma tabelami, typ uczestnictwa oraz stopień uczestnictwa tych tabel."
    },
    {
      "term": "3 rodzaje więzi",
      "definition": "Więź jeden-do-jednego, Więź jeden-do-wielu, Więź wiele-do-wielu"
    },
    {
      "term": "Związek jeden-do-jednego",
      "definition": "W relacji jeden-do-jednego każdy rekord w tabeli A może mieć tylko jeden dopasowany rekord z tabeli B, i tak samo każdy rekord w tabeli B może mieć tylko jeden dopasowany rekord z tabeli A. Ten typ relacji spotyka się rzadko, ponieważ większość informacji powiązanych w ten sposób byłoby zawartych w jednej tabeli."
    },
    {
      "term": "Związek jeden-do-wielu",
      "definition": "Jest najbardziej powszechnym typem relacji. W relacji jeden-do-wielu rekord w tabeli A może mieć wiele dopasowanych do niego rekordów z tabeli B, ale rekord w tabeli B ma tylko jeden dopasowany rekord w tabeli A."
    },
    {
      "term": "Związek wiele-do-wielu",
      "definition": "W relacji wiele-do-wielu, rekord w tabeli A może mieć wiele dopasowanych do niego rekordów z tabeli B i tak samo rekord w tabeli B może mieć wiele dopasowanych do niego rekordów z tabeli A. Jest to możliwe tylko przez zdefiniowanie trzeciej tabeli (nazywanej tabelą łącza), której klucz podstawowy składa się z dwóch pól z kluczy obcych z tabel A i B."
    },
    {
      "term": "typy danych",
      "definition": "Typy danych w MySQL możemy podzielić na 3 kategorie: Numeric Types (numeryczne), Date and Time Types (związane z datą i/lub czasem) oraz String Types (tekstowe)."
    },
    {
      "term": "Normalizacja to",
      "definition": "proces organizacji danych w bazie danych. Polega on na tworzeniu tabel i ustanawianiu pomiędzy nimi powiazań według reguł obowiązujących zarówno przy ochronie danych, jak i uelastycznianiu bazy danych przez eliminowanie powtarzających się i niespójnych zależności."
    },
    {
      "term": "Normalizując bazę danych",
      "definition": "usuwamy z niej nadmiarowość tzw. redundancje. Nadmiarowość w bazie danych bywa szkodliwa. Jej istnienie powoduje niepotrzebny wzrost objętości bazy danych, oraz prowadzi do problemów z utrzymaniem spójności danych"
    },
    {
      "term": "SQL (ang. Structured Query Language – Strukturalny Język Zapytań)",
      "definition": "język umożliwiający dostęp i przetwarzanie danych w relacyjnej bazie danych. Jest międzynarodowym standardem, do którego stosują się wszyscy producenci relacyjnych baz danych."
    },
    {
      "term": "Kiedy został opracowany SQL?",
      "definition": "w latach 70. w firmie IBM (SEQUEL). Stał się standardem w komunikacji z serwerami relacyjnych baz danych."
    },
    {
      "term": "Standardy SQL",
      "definition": "Konkurencyjność rynku spowodowała konieczność ustandaryzowania języka SQL - 1986, opracowany przez ANSI standard określany jako SQL:86."
    },
    {
      "term": "SQL DDL",
      "definition": "(Data Definition Language) – „język definicji danych”"
    },
    {
      "term": "SQL DML",
      "definition": "(Data Manipulation Language) – „język manipulacji danymi”"
    },
    {
      "term": "SQL DCL",
      "definition": "(Data Control Language) – „język kontroli nad danymi”"
    },
    {
      "term": "SQL DQL",
      "definition": "(Data Query Language) – „język definiowania zapytań”,"
    },
    {
      "term": "SQL TCL",
      "definition": "(Transaction Control Language) – obsługa transakcji np.**BEGIN TRANSACTION, COMMIT, ROLLBACK**."
    },
    {
      "term": "Transakcja",
      "definition": "jest sekwencją logicznie powiązanych operacji na bazie danych, która przeprowadza bazę danych z jednego stanu spójnego w inny stan spójny. Typy operacji na bazie danych obejmują: odczyt i zapis danych oraz zakończenie i akceptację (zatwierdzenie), lub wycofanie transakcji"
    },
    {
      "term": "Własności transakcji",
      "definition": "A(tomicity) C(onsistency) I(solation) D(urability)"
    },
    {
      "term": "Atomowość (A)",
      "definition": "Zbiór operacji wchodzących w skład transakcji jest niepodzielny: albo zostaną wykonane wszystkie operacje transakcji albo żadna (niepodzielność). Dotyczy to również wszystkich operacji transakcji wykonywanych na obiektach rzeczywistych (tak zwane akcje rzeczywiste) – np. wypłata gotówki z bankomatu."
    },
    {
      "term": "Spójność (C)",
      "definition": "Transakcja przeprowadza bazę danych z jednego stanu spójnego do innego stanu spójnego. W trakcie wykonywania transakcji baza danych może być przejściowo niespójna. Transakcja nie może naruszać ograniczeń integralnościowych"
    },
    {
      "term": "Izolacja (I)",
      "definition": "Transakcje są od siebie logicznie odseparowane. Transakcje oddziałują na siebie poprzez dane. Mimo współbieżnego wykonywania, transakcje widzą stan bazy danych tak, jak gdyby były wykonywane w sposób sekwencyjny Jeśli transakcja modyfikuje dane, to te dane mogą być czasowo niespójne, dlatego muszą być niedostępne dla innych transakcji dopóki transakcja nie skończy ich używać."
    },
    {
      "term": "Trwałość (D)",
      "definition": "Wyniki zatwierdzonych transakcji nie mogą zostać utracone w wyniku wystąpienia awarii systemu. Zatwierdzone dane w bazie danych, w przypadku awarii, muszą być odtwarzalne."
    },
    {
      "term": "Brudny odczyt (Dirty read)",
      "definition": "pierwsza transakcja modyfikuje wiersz, a druga go czyta, zanim zmiana została zatwierdzona przez instrukcję COMMIT. Jeśli pierwsza transakcja została anulowana, zmiana nie miała miejsca i druga transakcja przeczytała wiersz, który naprawdę nigdy nie istniał"
    },
    {
      "term": "Odczyt bez powtórzeń (Non-repeatable read)",
      "definition": "pierwsza transakcja czyta wiersz. Druga go usuwa lub modyfikuje i wykonuje COMMIT przed pierwszą. Teraz pierwsza transakcja mogłaby przeczytać ten sam wiersz jeszcze raz i otrzymać inne wyniki"
    },
    {
      "term": "Odczyt widmo (Phantom)",
      "definition": "pierwsza transakcja odczytuje wiersze spełniające predykat. Druga wstawia wartości (instrukcja INSERT) lub je modyfikuje (instrukcja UPDATE) tak, że one również spełniają predykat. Następne wykonanie tego samego zapytania przez pierwszą transakcję da inne wyniki"
    },
    {
      "term": "W języku SQL określono 4 poziomy izolacji transakcji",
      "definition": "SERIALIZABLE, REPEATABLE READS, READ COMMITED, READ UNCOMMITED"
    },
    {
      "term": "Metody usuwania konfliktów",
      "definition": "Blokady, Szeregowalność"
    },
    {
      "term": "Zakleszczenia",
      "definition": "(ang. deadlock) jest to cykl transakcji oczekujących wzajemnie na zwolnienie blokady przez inną transakcję w cyklu. O zakleszczeniu mówimy wtedy, kiedy dwie lub więcej transakcji wzajemnie blokują sobie - potrzebne do kontynuowania swojego działania - obiekty"
    },
    {
      "term": "Zakleszczenia - Metoda timeout",
      "definition": "gdy transakcja czeka bezczynnie na zwolnienie blokady dłużej niż ustalony odcinek czasu timeout, transakcja zostaje wycofana przez system."
    }

  ]

}

